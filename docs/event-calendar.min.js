/*!
EventCalendar v2.5.0
https://github.com/vkurko/calendar
*/
var EventCalendar = (function () {
	'use strict';

	/** @returns {void} */
	function noop() {}
	const identity = x => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign$1(tar, src) {
	  // @ts-ignore
	  for (const k in src) tar[k] = src[k];
	  return /** @type {T & S} */tar;
	}
	function run(fn) {
	  return fn();
	}
	function blank_object() {
	  return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
	  fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
	  return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
	  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
	}

	/** @returns {boolean} */
	function is_empty(obj) {
	  return Object.keys(obj).length === 0;
	}
	function subscribe(store) {
	  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    callbacks[_key - 1] = arguments[_key];
	  }
	  if (store == null) {
	    for (const callback of callbacks) {
	      callback(undefined);
	    }
	    return noop;
	  }
	  const unsub = store.subscribe(...callbacks);
	  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * https://svelte.dev/docs/svelte-store#get
	 * @template T
	 * @param {import('../store/public.js').Readable<T>} store
	 * @returns {T}
	 */
	function get_store_value(store) {
	  let value;
	  subscribe(store, _ => value = _)();
	  return value;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
	  component.$$.on_destroy.push(subscribe(store, callback));
	}
	function create_slot(definition, ctx, $$scope, fn) {
	  if (definition) {
	    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	    return definition[0](slot_ctx);
	  }
	}
	function get_slot_context(definition, ctx, $$scope, fn) {
	  return definition[1] && fn ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}
	function get_slot_changes(definition, $$scope, dirty, fn) {
	  if (definition[2] && fn) {
	    const lets = definition[2](fn(dirty));
	    if ($$scope.dirty === undefined) {
	      return lets;
	    }
	    if (typeof lets === 'object') {
	      const merged = [];
	      const len = Math.max($$scope.dirty.length, lets.length);
	      for (let i = 0; i < len; i += 1) {
	        merged[i] = $$scope.dirty[i] | lets[i];
	      }
	      return merged;
	    }
	    return $$scope.dirty | lets;
	  }
	  return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
	  if (slot_changes) {
	    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	    slot.p(slot_context, slot_changes);
	  }
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
	  if ($$scope.ctx.length > 32) {
	    const dirty = [];
	    const length = $$scope.ctx.length / 32;
	    for (let i = 0; i < length; i++) {
	      dirty[i] = -1;
	    }
	    return dirty;
	  }
	  return -1;
	}
	function set_store_value(store, ret, value) {
	  store.set(value);
	  return ret;
	}
	function action_destroyer(action_result) {
	  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	/** @type {typeof globalThis} */
	const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis :
	// @ts-ignore Node typings have this
	global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
	  target.appendChild(node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
	  target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
	  if (node.parentNode) {
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
	  for (let i = 0; i < iterations.length; i += 1) {
	    if (iterations[i]) iterations[i].d(detaching);
	  }
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
	  return document.createElement(name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
	  return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
	  return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
	  return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
	  node.addEventListener(event, handler, options);
	  return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function stop_propagation(fn) {
	  return function (event) {
	    event.stopPropagation();
	    // @ts-ignore
	    return fn.call(this, event);
	  };
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
	  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
	  return Array.from(element.childNodes);
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data(text, data) {
	  data = '' + data;
	  if (text.data === data) return;
	  text.data = /** @type {string} */data;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
	  if (value == null) {
	    node.style.removeProperty(key);
	  } else {
	    node.style.setProperty(key, value, important ? 'important' : '');
	  }
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail) {
	  let {
	    bubbles = false,
	    cancelable = false
	  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  return new CustomEvent(type, {
	    detail,
	    bubbles,
	    cancelable
	  });
	}
	function construct_svelte_component(component, props) {
	  return new component(props);
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
	  current_component = component;
	}
	function get_current_component() {
	  if (!current_component) throw new Error('Function called outside component initialization');
	  return current_component;
	}

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#beforeupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
	  get_current_component().$$.before_update.push(fn);
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
	  get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
	  get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
	  const component = get_current_component();
	  return function (type, detail) {
	    let {
	      cancelable = false
	    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    const callbacks = component.$$.callbacks[type];
	    if (callbacks) {
	      // TODO are there situations where events could be dispatched
	      // in a server (non-DOM) environment?
	      const event = custom_event( /** @type {string} */type, detail, {
	        cancelable
	      });
	      callbacks.slice().forEach(fn => {
	        fn.call(component, event);
	      });
	      return !event.defaultPrevented;
	    }
	    return true;
	  };
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#setcontext
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
	  get_current_component().$$.context.set(key, context);
	  return context;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#getcontext
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
	  return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
	  const callbacks = component.$$.callbacks[event.type];
	  if (callbacks) {
	    // @ts-ignore
	    callbacks.slice().forEach(fn => fn.call(this, event));
	  }
	}

	const dirty_components = [];
	const binding_callbacks = [];
	let render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = /* @__PURE__ */Promise.resolve();
	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
	  if (!update_scheduled) {
	    update_scheduled = true;
	    resolved_promise.then(flush);
	  }
	}

	/** @returns {Promise<void>} */
	function tick() {
	  schedule_update();
	  return resolved_promise;
	}

	/** @returns {void} */
	function add_render_callback(fn) {
	  render_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();
	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
	  // Do not reenter flush while dirty components are updated, as this can
	  // result in an infinite loop. Instead, let the inner flush handle it.
	  // Reentrancy is ok afterwards for bindings etc.
	  if (flushidx !== 0) {
	    return;
	  }
	  const saved_component = current_component;
	  do {
	    // first, call beforeUpdate functions
	    // and update components
	    try {
	      while (flushidx < dirty_components.length) {
	        const component = dirty_components[flushidx];
	        flushidx++;
	        set_current_component(component);
	        update(component.$$);
	      }
	    } catch (e) {
	      // reset dirty state to not end up in a deadlocked state and then rethrow
	      dirty_components.length = 0;
	      flushidx = 0;
	      throw e;
	    }
	    set_current_component(null);
	    dirty_components.length = 0;
	    flushidx = 0;
	    while (binding_callbacks.length) binding_callbacks.pop()();
	    // then, once components are updated, call
	    // afterUpdate functions. This may cause
	    // subsequent updates...
	    for (let i = 0; i < render_callbacks.length; i += 1) {
	      const callback = render_callbacks[i];
	      if (!seen_callbacks.has(callback)) {
	        // ...so guard against infinite loops
	        seen_callbacks.add(callback);
	        callback();
	      }
	    }
	    render_callbacks.length = 0;
	  } while (dirty_components.length);
	  while (flush_callbacks.length) {
	    flush_callbacks.pop()();
	  }
	  update_scheduled = false;
	  seen_callbacks.clear();
	  set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
	  if ($$.fragment !== null) {
	    $$.update();
	    run_all($$.before_update);
	    const dirty = $$.dirty;
	    $$.dirty = [-1];
	    $$.fragment && $$.fragment.p($$.ctx, dirty);
	    $$.after_update.forEach(add_render_callback);
	  }
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
	  const filtered = [];
	  const targets = [];
	  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
	  targets.forEach(c => c());
	  render_callbacks = filtered;
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
	  outros = {
	    r: 0,
	    c: [],
	    p: outros // parent group
	  };
	}

	/**
	 * @returns {void} */
	function check_outros() {
	  if (!outros.r) {
	    run_all(outros.c);
	  }
	  outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
	  if (block && block.i) {
	    outroing.delete(block);
	    block.i(local);
	  }
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
	  if (block && block.o) {
	    if (outroing.has(block)) return;
	    outroing.add(block);
	    outros.c.push(() => {
	      outroing.delete(block);
	      if (callback) {
	        if (detach) block.d(1);
	        callback();
	      }
	    });
	    block.o(local);
	  } else if (callback) {
	    callback();
	  }
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
	  return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);
	}

	/** @returns {void} */
	function outro_and_destroy_block(block, lookup) {
	  transition_out(block, 1, 1, () => {
	    lookup.delete(block.key);
	  });
	}

	/** @returns {any[]} */
	function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
	  let o = old_blocks.length;
	  let n = list.length;
	  let i = o;
	  const old_indexes = {};
	  while (i--) old_indexes[old_blocks[i].key] = i;
	  const new_blocks = [];
	  const new_lookup = new Map();
	  const deltas = new Map();
	  const updates = [];
	  i = n;
	  while (i--) {
	    const child_ctx = get_context(ctx, list, i);
	    const key = get_key(child_ctx);
	    let block = lookup.get(key);
	    if (!block) {
	      block = create_each_block(key, child_ctx);
	      block.c();
	    } else if (dynamic) {
	      // defer updates until all the DOM shuffling is done
	      updates.push(() => block.p(child_ctx, dirty));
	    }
	    new_lookup.set(key, new_blocks[i] = block);
	    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	  }
	  const will_move = new Set();
	  const did_move = new Set();
	  /** @returns {void} */
	  function insert(block) {
	    transition_in(block, 1);
	    block.m(node, next);
	    lookup.set(block.key, block);
	    next = block.first;
	    n--;
	  }
	  while (o && n) {
	    const new_block = new_blocks[n - 1];
	    const old_block = old_blocks[o - 1];
	    const new_key = new_block.key;
	    const old_key = old_block.key;
	    if (new_block === old_block) {
	      // do nothing
	      next = new_block.first;
	      o--;
	      n--;
	    } else if (!new_lookup.has(old_key)) {
	      // remove old block
	      destroy(old_block, lookup);
	      o--;
	    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
	      insert(new_block);
	    } else if (did_move.has(old_key)) {
	      o--;
	    } else if (deltas.get(new_key) > deltas.get(old_key)) {
	      did_move.add(new_key);
	      insert(new_block);
	    } else {
	      will_move.add(old_key);
	      o--;
	    }
	  }
	  while (o--) {
	    const old_block = old_blocks[o];
	    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	  }
	  while (n) insert(new_blocks[n - 1]);
	  run_all(updates);
	  return new_blocks;
	}

	/** @returns {void} */
	function create_component(block) {
	  block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
	  const {
	    fragment,
	    after_update
	  } = component.$$;
	  fragment && fragment.m(target, anchor);
	  // onMount happens before the initial afterUpdate
	  add_render_callback(() => {
	    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
	    // if the component was destroyed immediately
	    // it will update the `$$.on_destroy` reference to `null`.
	    // the destructured on_destroy may still reference to the old array
	    if (component.$$.on_destroy) {
	      component.$$.on_destroy.push(...new_on_destroy);
	    } else {
	      // Edge case - component was destroyed immediately,
	      // most likely as a result of a binding initialising
	      run_all(new_on_destroy);
	    }
	    component.$$.on_mount = [];
	  });
	  after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
	  const $$ = component.$$;
	  if ($$.fragment !== null) {
	    flush_render_callbacks($$.after_update);
	    run_all($$.on_destroy);
	    $$.fragment && $$.fragment.d(detaching);
	    // TODO null out other refs, including component.$$ (but need to
	    // preserve final state?)
	    $$.on_destroy = $$.fragment = null;
	    $$.ctx = [];
	  }
	}

	/** @returns {void} */
	function make_dirty(component, i) {
	  if (component.$$.dirty[0] === -1) {
	    dirty_components.push(component);
	    schedule_update();
	    component.$$.dirty.fill(0);
	  }
	  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(component, options, instance, create_fragment, not_equal, props) {
	  let append_styles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
	  let dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
	  const parent_component = current_component;
	  set_current_component(component);
	  /** @type {import('./private.js').T$$} */
	  const $$ = component.$$ = {
	    fragment: null,
	    ctx: [],
	    // state
	    props,
	    update: noop,
	    not_equal,
	    bound: blank_object(),
	    // lifecycle
	    on_mount: [],
	    on_destroy: [],
	    on_disconnect: [],
	    before_update: [],
	    after_update: [],
	    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	    // everything else
	    callbacks: blank_object(),
	    dirty,
	    skip_bound: false,
	    root: options.target || parent_component.$$.root
	  };
	  append_styles && append_styles($$.root);
	  let ready = false;
	  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
	    const value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;
	    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
	      if (ready) make_dirty(component, i);
	    }
	    return ret;
	  }) : [];
	  $$.update();
	  ready = true;
	  run_all($$.before_update);
	  // `false` as a special case of no DOM component
	  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	  if (options.target) {
	    if (options.hydrate) {
	      // TODO: what is the correct type here?
	      // @ts-expect-error
	      const nodes = children(options.target);
	      $$.fragment && $$.fragment.l(nodes);
	      nodes.forEach(detach);
	    } else {
	      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	      $$.fragment && $$.fragment.c();
	    }
	    if (options.intro) transition_in(component.$$.fragment);
	    mount_component(component, options.target, options.anchor);
	    flush();
	  }
	  set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
	  /**
	   * ### PRIVATE API
	   *
	   * Do not use, may change at any time
	   *
	   * @type {any}
	   */
	  $$ = undefined;
	  /**
	   * ### PRIVATE API
	   *
	   * Do not use, may change at any time
	   *
	   * @type {any}
	   */
	  $$set = undefined;

	  /** @returns {void} */
	  $destroy() {
	    destroy_component(this, 1);
	    this.$destroy = noop;
	  }

	  /**
	   * @template {Extract<keyof Events, string>} K
	   * @param {K} type
	   * @param {((e: Events[K]) => void) | null | undefined} callback
	   * @returns {() => void}
	   */
	  $on(type, callback) {
	    if (!is_function(callback)) {
	      return noop;
	    }
	    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
	    callbacks.push(callback);
	    return () => {
	      const index = callbacks.indexOf(callback);
	      if (index !== -1) callbacks.splice(index, 1);
	    };
	  }

	  /**
	   * @param {Partial<Props>} props
	   * @returns {void}
	   */
	  $set(props) {
	    if (this.$$set && !is_empty(props)) {
	      this.$$.skip_bound = true;
	      this.$$set(props);
	      this.$$.skip_bound = false;
	    }
	  }
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	const subscriber_queue = [];

	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#readable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function readable(value, start) {
	  return {
	    subscribe: writable(value, start).subscribe
	  };
	}

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value) {
	  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	  /** @type {import('./public.js').Unsubscriber} */
	  let stop;
	  /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	  const subscribers = new Set();
	  /** @param {T} new_value
	   * @returns {void}
	   */
	  function set(new_value) {
	    if (safe_not_equal(value, new_value)) {
	      value = new_value;
	      if (stop) {
	        // store is ready
	        const run_queue = !subscriber_queue.length;
	        for (const subscriber of subscribers) {
	          subscriber[1]();
	          subscriber_queue.push(subscriber, value);
	        }
	        if (run_queue) {
	          for (let i = 0; i < subscriber_queue.length; i += 2) {
	            subscriber_queue[i][0](subscriber_queue[i + 1]);
	          }
	          subscriber_queue.length = 0;
	        }
	      }
	    }
	  }

	  /**
	   * @param {import('./public.js').Updater<T>} fn
	   * @returns {void}
	   */
	  function update(fn) {
	    set(fn(value));
	  }

	  /**
	   * @param {import('./public.js').Subscriber<T>} run
	   * @param {import('./private.js').Invalidator<T>} [invalidate]
	   * @returns {import('./public.js').Unsubscriber}
	   */
	  function subscribe(run) {
	    let invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	    /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
	    const subscriber = [run, invalidate];
	    subscribers.add(subscriber);
	    if (subscribers.size === 1) {
	      stop = start(set, update) || noop;
	    }
	    run(value);
	    return () => {
	      subscribers.delete(subscriber);
	      if (subscribers.size === 0 && stop) {
	        stop();
	        stop = null;
	      }
	    };
	  }
	  return {
	    set,
	    update,
	    subscribe
	  };
	}

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @param {S} stores
	 * @param {Function} fn
	 * @param {T} [initial_value]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function derived(stores, fn, initial_value) {
	  const single = !Array.isArray(stores);
	  /** @type {Array<import('./public.js').Readable<any>>} */
	  const stores_array = single ? [stores] : stores;
	  if (!stores_array.every(Boolean)) {
	    throw new Error('derived() expects stores as input, got a falsy value');
	  }
	  const auto = fn.length < 2;
	  return readable(initial_value, (set, update) => {
	    let started = false;
	    const values = [];
	    let pending = 0;
	    let cleanup = noop;
	    const sync = () => {
	      if (pending) {
	        return;
	      }
	      cleanup();
	      const result = fn(single ? values[0] : values, set, update);
	      if (auto) {
	        set(result);
	      } else {
	        cleanup = is_function(result) ? result : noop;
	      }
	    };
	    const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {
	      values[i] = value;
	      pending &= ~(1 << i);
	      if (started) {
	        sync();
	      }
	    }, () => {
	      pending |= 1 << i;
	    }));
	    started = true;
	    sync();
	    return function stop() {
	      run_all(unsubscribers);
	      cleanup();
	      // We need to set this to false because callbacks can still happen despite having unsubscribed:
	      // Callbacks might already be placed in the queue which doesn't know it should no longer
	      // invoke this derived store.
	      started = false;
	    };
	  });
	}

	function keyEnter(fn) {
	  return function (e) {
	    return e.key === 'Enter' || e.key === ' ' && !e.preventDefault() // prevent page scroll down
	    ? fn.call(this, e) : undefined;
	  };
	}
	function setContent(node, content) {
	  let actions = {
	    update(content) {
	      if (typeof content == 'string') {
	        node.innerText = content;
	      } else if (content?.domNodes) {
	        node.replaceChildren(...content.domNodes);
	      } else if (content?.html) {
	        node.innerHTML = content.html;
	      }
	    }
	  };
	  actions.update(content);
	  return actions;
	}

	/** Dispatch event occurred outside of node */
	function outsideEvent(node, type) {
	  const handlePointerDown = jsEvent => {
	    if (node && !node.contains(jsEvent.target)) {
	      node.dispatchEvent(new CustomEvent(type + 'outside', {
	        detail: {
	          jsEvent
	        }
	      }));
	    }
	  };
	  document.addEventListener(type, handlePointerDown, true);
	  return {
	    destroy() {
	      document.removeEventListener(type, handlePointerDown, true);
	    }
	  };
	}
	const DAY_IN_SECONDS = 86400;
	function createDate() {
	  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	  if (input !== undefined) {
	    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
	  }
	  return _fromLocalDate(new Date());
	}
	function createDuration(input) {
	  if (typeof input === 'number') {
	    input = {
	      seconds: input
	    };
	  } else if (typeof input === 'string') {
	    // Expected format hh[:mm[:ss]]
	    let seconds = 0,
	      exp = 2;
	    for (let part of input.split(':', 3)) {
	      seconds += parseInt(part, 10) * Math.pow(60, exp--);
	    }
	    input = {
	      seconds
	    };
	  } else if (input instanceof Date) {
	    input = {
	      hours: input.getUTCHours(),
	      minutes: input.getUTCMinutes(),
	      seconds: input.getUTCSeconds()
	    };
	  }
	  let weeks = input.weeks || input.week || 0;
	  return {
	    years: input.years || input.year || 0,
	    months: input.months || input.month || 0,
	    days: weeks * 7 + (input.days || input.day || 0),
	    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
	    inWeeks: !!weeks
	  };
	}
	function cloneDate(date) {
	  return new Date(date.getTime());
	}
	function addDuration(date, duration) {
	  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
	  let month = date.getUTCMonth() + x * duration.months;
	  date.setUTCMonth(month);
	  month %= 12;
	  if (month < 0) {
	    month += 12;
	  }
	  while (date.getUTCMonth() !== month) {
	    subtractDay(date);
	  }
	  date.setUTCDate(date.getUTCDate() + x * duration.days);
	  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
	  return date;
	}
	function subtractDuration(date, duration) {
	  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  return addDuration(date, duration, -x);
	}
	function addDay(date) {
	  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  date.setUTCDate(date.getUTCDate() + x);
	  return date;
	}
	function subtractDay(date) {
	  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  return addDay(date, -x);
	}
	function setMidnight(date) {
	  date.setUTCHours(0, 0, 0, 0);
	  return date;
	}
	function toLocalDate(date) {
	  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
	}
	function toISOString(date) {
	  let len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 19;
	  return date.toISOString().substring(0, len);
	}
	function datesEqual(date1) {
	  for (var _len = arguments.length, dates2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    dates2[_key - 1] = arguments[_key];
	  }
	  return dates2.every(date2 => date1.getTime() === date2.getTime());
	}
	function nextClosestDay(date, day) {
	  let diff = day - date.getUTCDay();
	  date.setUTCDate(date.getUTCDate() + (diff >= 0 ? diff : diff + 7));
	  return date;
	}
	function prevClosestDay(date, day) {
	  let diff = day - date.getUTCDay();
	  date.setUTCDate(date.getUTCDate() + (diff <= 0 ? diff : diff - 7));
	  return date;
	}

	/**
	 * Check whether given date is string which contains no time part
	  */
	function noTimePart(date) {
	  return typeof date === 'string' && date.length <= 10;
	}

	/**
	 * Copy time from one date to another
	 */
	function copyTime(toDate, fromDate) {
	  toDate.setUTCHours(fromDate.getUTCHours(), fromDate.getUTCMinutes(), fromDate.getUTCSeconds(), 0);
	  return toDate;
	}

	/**
	 * Private functions
	 */

	function _fromLocalDate(date) {
	  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
	}
	function _fromISOString(str) {
	  const parts = str.match(/\d+/g);
	  return new Date(Date.UTC(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]), Number(parts[3] || 0), Number(parts[4] || 0), Number(parts[5] || 0)));
	}
	function debounce(fn, handle, queueStore) {
	  queueStore.update(queue => queue.set(handle, fn));
	}
	function flushDebounce(queue) {
	  run_all(queue);
	  queue.clear();
	}
	function assign() {
	  return Object.assign(...arguments);
	}
	function keys(object) {
	  return Object.keys(object);
	}
	function floor(value) {
	  return Math.floor(value);
	}
	function min() {
	  return Math.min(...arguments);
	}
	function max() {
	  return Math.max(...arguments);
	}
	function symbol() {
	  return Symbol('ec');
	}
	function createElement(tag, className, content) {
	  let attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
	  let el = document.createElement(tag);
	  el.className = className;
	  if (typeof content == 'string') {
	    el.innerText = content;
	  } else if (content.domNodes) {
	    el.replaceChildren(...content.domNodes);
	  } else if (content.html) {
	    el.innerHTML = content.html;
	  }
	  for (let attr of attrs) {
	    el.setAttribute(...attr);
	  }
	  return el;
	}
	function hasYScroll(el) {
	  return el.scrollHeight > el.clientHeight;
	}
	function rect(el) {
	  return el.getBoundingClientRect();
	}
	function ancestor(el, up) {
	  while (up--) {
	    el = el.parentElement;
	  }
	  return el;
	}
	function height(el) {
	  return rect(el).height;
	}
	let payloadProp = symbol();
	function setPayload(el, payload) {
	  el[payloadProp] = payload;
	}
	function hasPayload(el) {
	  return !!el?.[payloadProp];
	}
	function getPayload(el) {
	  return el[payloadProp];
	}
	function getElementWithPayload(x, y) {
	  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	  for (let el of root.elementsFromPoint(x, y)) {
	    if (hasPayload(el)) {
	      return el;
	    }
	    /** @see https://github.com/vkurko/calendar/issues/142 */
	    if (el.shadowRoot) {
	      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
	      if (shadowEl) {
	        return shadowEl;
	      }
	    }
	  }
	  return null;
	}
	function createView(view, _viewTitle, _currentRange, _activeRange) {
	  return {
	    type: view,
	    title: _viewTitle,
	    currentStart: _currentRange.start,
	    currentEnd: _currentRange.end,
	    activeStart: _activeRange.start,
	    activeEnd: _activeRange.end,
	    calendar: undefined
	  };
	}
	function toViewWithLocalDates(view) {
	  view = assign({}, view);
	  view.currentStart = toLocalDate(view.currentStart);
	  view.currentEnd = toLocalDate(view.currentEnd);
	  view.activeStart = toLocalDate(view.activeStart);
	  view.activeEnd = toLocalDate(view.activeEnd);
	  return view;
	}
	function listView(view) {
	  return view.startsWith('list');
	}
	let eventId = 1;
	function createEvents(input) {
	  return input.map(event => ({
	    id: 'id' in event ? String(event.id) : `{generated-${eventId++}}`,
	    resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : 'resourceId' in event ? [String(event.resourceId)] : [],
	    allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
	    start: createDate(event.start),
	    end: createDate(event.end),
	    title: event.title || '',
	    titleHTML: event.titleHTML || '',
	    editable: event.editable,
	    startEditable: event.startEditable,
	    durationEditable: event.durationEditable,
	    display: event.display || 'auto',
	    extendedProps: event.extendedProps || {},
	    backgroundColor: event.backgroundColor || event.color,
	    textColor: event.textColor
	  }));
	}
	function createEventSources(input) {
	  return input.map(source => ({
	    events: source.events,
	    url: source.url && source.url.trimEnd('&') || '',
	    method: source.method && source.method.toUpperCase() || 'GET',
	    extraParams: source.extraParams || {}
	  }));
	}
	function createEventChunk(event, start, end) {
	  return {
	    start: event.start > start ? event.start : start,
	    end: event.end < end ? event.end : end,
	    event
	  };
	}
	function sortEventChunks(chunks) {
	  // Sort by start date (all-day events always on top)
	  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
	}

	/**
	 * Prepare event chunks for month view and all-day slot in week view
	 */
	function prepareEventChunks(chunks, hiddenDays) {
	  let longChunks = {};
	  if (chunks.length) {
	    sortEventChunks(chunks);
	    let prevChunk;
	    for (let chunk of chunks) {
	      let dates = [];
	      let date = setMidnight(cloneDate(chunk.start));
	      while (chunk.end > date) {
	        if (!hiddenDays.includes(date.getUTCDay())) {
	          dates.push(cloneDate(date));
	          if (dates.length > 1) {
	            let key = date.getTime();
	            if (longChunks[key]) {
	              longChunks[key].chunks.push(chunk);
	            } else {
	              longChunks[key] = {
	                sorted: false,
	                chunks: [chunk]
	              };
	            }
	          }
	        }
	        addDay(date);
	      }
	      if (dates.length) {
	        chunk.date = dates[0];
	        chunk.days = dates.length;
	        chunk.dates = dates;
	        if (chunk.start < dates[0]) {
	          chunk.start = dates[0];
	        }
	        if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
	          chunk.end = dates[dates.length - 1];
	        }
	      } else {
	        chunk.date = setMidnight(cloneDate(chunk.start));
	        chunk.days = 1;
	        chunk.dates = [chunk.date];
	      }
	      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
	        chunk.prev = prevChunk;
	      }
	      prevChunk = chunk;
	    }
	  }
	  return longChunks;
	}
	function repositionEvent(chunk, longChunks, height) {
	  chunk.top = 0;
	  if (chunk.prev) {
	    chunk.top = chunk.prev.bottom + 1;
	  }
	  chunk.bottom = chunk.top + height;
	  let margin = 1;
	  let key = chunk.date.getTime();
	  if (longChunks[key]?.sorted || longChunks[key]?.chunks.every(chunk => 'top' in chunk)) {
	    if (!longChunks[key].sorted) {
	      longChunks[key].chunks.sort((a, b) => a.top - b.top);
	      longChunks[key].sorted = true;
	    }
	    for (let longChunk of longChunks[key].chunks) {
	      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
	        let offset = longChunk.bottom - chunk.top + 1;
	        margin += offset;
	        chunk.top += offset;
	        chunk.bottom += offset;
	      }
	    }
	  }
	  return margin;
	}
	function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
	  let timeText = _intlEventTime.formatRange(chunk.start, displayEventEnd && chunk.event.display !== 'pointer' ? copyTime(cloneDate(chunk.start), chunk.end) // make Intl.formatRange output only the time part
	  : chunk.start);
	  let content;
	  if (eventContent) {
	    content = is_function(eventContent) ? eventContent({
	      event: toEventWithLocalDates(chunk.event),
	      timeText,
	      view: toViewWithLocalDates(_view)
	    }) : eventContent;
	  } else {
	    let domNodes;
	    switch (chunk.event.display) {
	      case 'background':
	        domNodes = [];
	        break;
	      case 'pointer':
	        domNodes = [createTimeElement(timeText, chunk, theme)];
	        break;
	      default:
	        domNodes = [...(chunk.event.allDay ? [] : [createTimeElement(timeText, chunk, theme)]), createElement('h4', theme.eventTitle, chunk.event.title)];
	    }
	    content = {
	      domNodes
	    };
	  }
	  return [timeText, content];
	}
	function createTimeElement(timeText, chunk, theme) {
	  return createElement('time', theme.eventTime, timeText, [['datetime', toISOString(chunk.start)]]);
	}
	function createEventClasses(eventClassNames, event, _view) {
	  if (eventClassNames) {
	    if (is_function(eventClassNames)) {
	      eventClassNames = eventClassNames({
	        event: toEventWithLocalDates(event),
	        view: toViewWithLocalDates(_view)
	      });
	    }
	    return Array.isArray(eventClassNames) ? eventClassNames : [eventClassNames];
	  }
	  return [];
	}
	function toEventWithLocalDates(event) {
	  return _cloneEvent(event, toLocalDate);
	}
	function cloneEvent(event) {
	  return _cloneEvent(event, cloneDate);
	}
	function _cloneEvent(event, dateFn) {
	  event = assign({}, event);
	  event.start = dateFn(event.start);
	  event.end = dateFn(event.end);
	  return event;
	}

	/**
	 * Check whether the event intersects with the given date range and resource
	 * @param event
	 * @param start
	 * @param end
	 * @param [resource]
	 * @param [timeMode]  Zero-length events should be allowed (@see https://github.com/vkurko/calendar/issues/50), except in time mode
	 * @return boolean
	 */
	function eventIntersects(event, start, end, resource, timeMode) {
	  return (event.start < end && event.end > start || !timeMode && datesEqual(event.start, event.end, start)) && (resource === undefined || event.resourceIds.includes(resource.id));
	}
	function helperEvent(display) {
	  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
	}
	function bgEvent(display) {
	  return display === 'background';
	}
	function previewEvent(display) {
	  return display === 'preview';
	}
	function ghostEvent(display) {
	  return display === 'ghost';
	}
	function pointerEvent(display) {
	  return display === 'pointer';
	}
	function btnTextDay(text) {
	  return btnText(text, 'day');
	}
	function btnTextWeek(text) {
	  return btnText(text, 'week');
	}
	function btnTextMonth(text) {
	  return btnText(text, 'month');
	}
	function btnTextYear(text) {
	  return btnText(text, 'year');
	}
	function btnText(text, period) {
	  return {
	    ...text,
	    next: 'Next ' + period,
	    prev: 'Previous ' + period
	  };
	}
	function themeView(view) {
	  return theme => ({
	    ...theme,
	    view
	  });
	}
	function intl(locale, format) {
	  return derived([locale, format], _ref => {
	    let [$locale, $format] = _ref;
	    let intl = is_function($format) ? {
	      format: $format
	    } : new Intl.DateTimeFormat($locale, $format);
	    return {
	      format: date => intl.format(toLocalDate(date))
	    };
	  });
	}
	function intlRange(locale, format) {
	  return derived([locale, format], _ref2 => {
	    let [$locale, $format] = _ref2;
	    let intl = is_function($format) ? {
	      formatRange: $format
	    } : new Intl.DateTimeFormat($locale, $format);
	    return {
	      formatRange: (start, end) => intl.formatRange(toLocalDate(start), toLocalDate(end))
	    };
	  });
	}
	function createOptions(plugins) {
	  let options = {
	    allDayContent: undefined,
	    allDaySlot: true,
	    buttonText: {
	      today: 'today'
	    },
	    date: new Date(),
	    datesSet: undefined,
	    dayHeaderFormat: {
	      weekday: 'short',
	      month: 'numeric',
	      day: 'numeric'
	    },
	    dayHeaderAriaLabelFormat: {
	      dateStyle: 'long'
	    },
	    displayEventEnd: true,
	    duration: {
	      weeks: 1
	    },
	    events: [],
	    eventBackgroundColor: undefined,
	    eventTextColor: undefined,
	    eventClassNames: undefined,
	    eventClick: undefined,
	    eventColor: undefined,
	    eventContent: undefined,
	    eventDidMount: undefined,
	    eventMouseEnter: undefined,
	    eventMouseLeave: undefined,
	    eventSources: [],
	    eventTimeFormat: {
	      hour: 'numeric',
	      minute: '2-digit'
	    },
	    firstDay: 0,
	    flexibleSlotTimeLimits: false,
	    // ec option
	    headerToolbar: {
	      start: 'title',
	      center: '',
	      end: 'today prev,next'
	    },
	    height: undefined,
	    hiddenDays: [],
	    highlightedDates: [],
	    // ec option
	    lazyFetching: true,
	    loading: undefined,
	    locale: undefined,
	    nowIndicator: false,
	    selectable: false,
	    scrollTime: '06:00:00',
	    slotDuration: '00:30:00',
	    slotEventOverlap: true,
	    slotHeight: 24,
	    // ec option
	    slotLabelFormat: {
	      hour: 'numeric',
	      minute: '2-digit'
	    },
	    slotMaxTime: '24:00:00',
	    slotMinTime: '00:00:00',
	    theme: {
	      allDay: 'ec-all-day',
	      active: 'ec-active',
	      bgEvent: 'ec-bg-event',
	      bgEvents: 'ec-bg-events',
	      body: 'ec-body',
	      button: 'ec-button',
	      buttonGroup: 'ec-button-group',
	      calendar: 'ec',
	      compact: 'ec-compact',
	      content: 'ec-content',
	      day: 'ec-day',
	      dayHead: 'ec-day-head',
	      days: 'ec-days',
	      event: 'ec-event',
	      eventBody: 'ec-event-body',
	      eventTime: 'ec-event-time',
	      eventTitle: 'ec-event-title',
	      events: 'ec-events',
	      extra: 'ec-extra',
	      handle: 'ec-handle',
	      header: 'ec-header',
	      hiddenScroll: 'ec-hidden-scroll',
	      highlight: 'ec-highlight',
	      icon: 'ec-icon',
	      line: 'ec-line',
	      lines: 'ec-lines',
	      nowIndicator: 'ec-now-indicator',
	      otherMonth: 'ec-other-month',
	      sidebar: 'ec-sidebar',
	      sidebarTitle: 'ec-sidebar-title',
	      today: 'ec-today',
	      time: 'ec-time',
	      title: 'ec-title',
	      toolbar: 'ec-toolbar',
	      view: '',
	      weekdays: ['ec-sun', 'ec-mon', 'ec-tue', 'ec-wed', 'ec-thu', 'ec-fri', 'ec-sat'],
	      withScroll: 'ec-with-scroll'
	    },
	    titleFormat: {
	      year: 'numeric',
	      month: 'short',
	      day: 'numeric'
	    },
	    view: undefined,
	    viewDidMount: undefined,
	    views: {}
	  };
	  for (let plugin of plugins) {
	    plugin.createOptions?.(options);
	  }
	  return options;
	}
	function createParsers(plugins) {
	  let parsers = {
	    date: date => setMidnight(createDate(date)),
	    duration: createDuration,
	    events: createEvents,
	    eventSources: createEventSources,
	    hiddenDays: days => [...new Set(days)],
	    highlightedDates: dates => dates.map(createDate),
	    scrollTime: createDuration,
	    slotDuration: createDuration,
	    slotMaxTime: createDuration,
	    slotMinTime: createDuration
	  };
	  for (let plugin of plugins) {
	    plugin.createParsers?.(parsers);
	  }
	  return parsers;
	}
	function diff(options, prevOptions) {
	  let diff = [];
	  for (let key of keys(options)) {
	    if (options[key] !== prevOptions[key]) {
	      diff.push([key, options[key]]);
	    }
	  }
	  assign(prevOptions, options);
	  return diff;
	}
	function dayGrid(state) {
	  return derived(state.view, $view => $view?.startsWith('dayGrid'));
	}
	function customGrid(state) {
	  return derived(state.view, $view => $view?.startsWith('customGrid'));
	}
	function activeRange(state) {
	  return derived([state._currentRange, state.firstDay, state.slotMaxTime, state._dayGrid, state._customGrid], _ref3 => {
	    let [$_currentRange, $firstDay, $slotMaxTime, $_dayGrid, $_customGrid] = _ref3;
	    let start = cloneDate($_currentRange.start);
	    let end = cloneDate($_currentRange.end);
	    if ($_dayGrid) {
	      // First day of week
	      prevClosestDay(start, $firstDay);
	      nextClosestDay(end, $firstDay);
	    } else if ($_customGrid) {
	      //simplification possible
	      // First day of week
	      prevClosestDay(start, $firstDay);
	      nextClosestDay(end, $firstDay);
	    } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
	      addDuration(subtractDay(end), $slotMaxTime);
	      let start2 = subtractDay(cloneDate(end));
	      if (start2 < start) {
	        start = start2;
	      }
	    }
	    return {
	      start,
	      end
	    };
	  });
	}
	function currentRange(state) {
	  return derived([state.date, state.duration, state.firstDay, state._dayGrid, state._customGrid], _ref4 => {
	    let [$date, $duration, $firstDay, $_dayGrid, $_customGrid] = _ref4;
	    let start = cloneDate($date),
	      end;
	    if ($_dayGrid) {
	      start.setUTCDate(1);
	    } else if ($_customGrid) {
	      //simplification possible
	      start.setUTCDate(1);
	    } else if ($duration.inWeeks) {
	      // First day of week
	      prevClosestDay(start, $firstDay);
	    }
	    end = addDuration(cloneDate(start), $duration);
	    return {
	      start,
	      end
	    };
	  });
	}
	function viewDates(state) {
	  return derived([state._activeRange, state.hiddenDays], _ref5 => {
	    let [$_activeRange, $hiddenDays] = _ref5;
	    let dates = [];
	    let date = setMidnight(cloneDate($_activeRange.start));
	    let end = setMidnight(cloneDate($_activeRange.end));
	    while (date < end) {
	      if (!$hiddenDays.includes(date.getUTCDay())) {
	        dates.push(cloneDate(date));
	      }
	      addDay(date);
	    }
	    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
	      // Try to move the date
	      state.date.update(date => {
	        while ($hiddenDays.includes(date.getUTCDay())) {
	          addDay(date);
	        }
	        return date;
	      });
	      dates = get_store_value(state._viewDates);
	    }
	    return dates;
	  });
	}
	function viewTitle(state) {
	  return derived([state.date, state._activeRange, state._intlTitle, state._dayGrid, state._customGrid], _ref6 => {
	    let [$date, $_activeRange, $_intlTitle, $_dayGrid, $_customGrid] = _ref6;
	    if ($_dayGrid) {
	      return $_dayGrid;
	    } else if ($_customGrid) {
	      return $_customGrid;
	    }
	    $_intlTitle.formatRange($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
	  });
	}
	function view(state) {
	  return derived([state.view, state._viewTitle, state._currentRange, state._activeRange], args => createView(...args));
	}
	function events(state) {
	  let _events = writable([]);
	  let abortController;
	  let fetching = 0;
	  let debounceHandle = {};
	  derived([state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading], (values, set) => debounce(() => {
	    let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
	    if (!$eventSources.length) {
	      set($events);
	      return;
	    }
	    // Do not fetch if new range is within the previous one
	    if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
	      if (abortController) {
	        // Abort previous request
	        abortController.abort();
	      }
	      // Create new abort controller
	      abortController = new AbortController();
	      // Call loading hook
	      if (is_function($loading) && !fetching) {
	        $loading(true);
	      }
	      let stopLoading = () => {
	        if (--fetching === 0 && is_function($loading)) {
	          $loading(false);
	        }
	      };
	      let events = [];
	      // Prepare handlers
	      let failure = e => stopLoading();
	      let success = data => {
	        events = events.concat(createEvents(data));
	        set(events);
	        stopLoading();
	      };
	      // Prepare other stuff
	      let startStr = toISOString($_activeRange.start);
	      let endStr = toISOString($_activeRange.end);
	      // Loop over event sources
	      for (let source of $eventSources) {
	        if (is_function(source.events)) {
	          // Events as a function
	          let result = source.events({
	            start: toLocalDate($_activeRange.start),
	            end: toLocalDate($_activeRange.end),
	            startStr,
	            endStr
	          }, success, failure);
	          if (result !== undefined) {
	            Promise.resolve(result).then(success, failure);
	          }
	        } else {
	          // Events as a JSON feed
	          // Prepare params
	          let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
	          params.start = startStr;
	          params.end = endStr;
	          params = new URLSearchParams(params);
	          // Prepare fetch
	          let url = source.url,
	            headers = {},
	            body;
	          if (['GET', 'HEAD'].includes(source.method)) {
	            url += (url.includes('?') ? '&' : '?') + params;
	          } else {
	            headers['content-type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
	            body = String(params); // Safari 10.1 doesn't convert to string automatically
	          }
	          // Do the fetch
	          fetch(url, {
	            method: source.method,
	            headers,
	            body,
	            signal: abortController.signal,
	            credentials: 'same-origin'
	          }).then(response => response.json()).then(success).catch(failure);
	        }
	        ++fetching;
	      }
	      // Save current range for future requests
	      $_fetchedRange.start = $_activeRange.start;
	      $_fetchedRange.end = $_activeRange.end;
	    }
	  }, debounceHandle, state._queue), []).subscribe(_events.set);
	  return _events;
	}
	function now() {
	  return readable(createDate(), set => {
	    let interval = setInterval(() => {
	      set(createDate());
	    }, 1000);
	    return () => clearInterval(interval);
	  });
	}
	function today(state) {
	  return derived(state._now, $_now => setMidnight(cloneDate($_now)));
	}
	class State {
	  constructor(plugins, input) {
	    plugins = plugins || [];

	    // Create options
	    let options = createOptions(plugins);
	    let parsers = createParsers(plugins);

	    // Parse options
	    options = parseOpts(options, parsers);
	    input = parseOpts(input, parsers);

	    // Create stores for options
	    for (let [option, value] of Object.entries(options)) {
	      this[option] = writable(value);
	    }

	    // Private stores
	    this._queue = writable(new Map()); // debounce queue
	    this._auxiliary = writable([]); // auxiliary components
	    this._dayGrid = dayGrid(this);
	    this._customGrid = customGrid(this);
	    this._currentRange = currentRange(this);
	    this._activeRange = activeRange(this);
	    this._fetchedRange = writable({
	      start: undefined,
	      end: undefined
	    });
	    this._events = events(this);
	    this._now = now();
	    this._today = today(this);
	    this._intlEventTime = intlRange(this.locale, this.eventTimeFormat);
	    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
	    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
	    this._intlDayHeaderAL = intl(this.locale, this.dayHeaderAriaLabelFormat);
	    this._intlTitle = intlRange(this.locale, this.titleFormat);
	    this._bodyEl = writable(undefined);
	    this._scrollable = writable(false);
	    this._viewTitle = viewTitle(this);
	    this._viewDates = viewDates(this);
	    this._view = view(this);
	    this._viewComponent = writable(undefined);
	    // Resources
	    this._resBgColor = writable(noop);
	    this._resTxtColor = writable(noop);
	    // Interaction
	    this._interaction = writable({});
	    this._iEvents = writable([null, null]); // interaction events: [drag/resize, pointer]
	    this._iClasses = writable(identity); // interaction event css classes
	    this._iClass = writable(undefined); // interaction css class for entire calendar

	    // Set & Get
	    this._set = (key, value) => {
	      if (validKey(key, this)) {
	        if (parsers[key]) {
	          value = parsers[key](value);
	        }
	        this[key].set(value);
	      }
	    };
	    this._get = key => validKey(key, this) ? get_store_value(this[key]) : undefined;

	    // Let plugins create their private stores
	    for (let plugin of plugins) {
	      plugin.createStores?.(this);
	    }
	    if (input.view) {
	      // Set initial view based on input
	      this.view.set(input.view);
	    }

	    // Set options for each view
	    let views = new Set([...keys(options.views), ...keys(input.views ?? {})]);
	    for (let view of views) {
	      let defOpts = mergeOpts(options, options.views[view] ?? {});
	      let opts = mergeOpts(defOpts, input, input.views?.[view] ?? {});
	      let component = opts.component;
	      // Make sure we deal with valid opts from now on
	      filterOpts(opts, this);
	      // Process options
	      for (let key of keys(opts)) {
	        let {
	          set,
	          _set = set,
	          ...rest
	        } = this[key];
	        this[key] = {
	          // Set value in all views
	          set: ['buttonText', 'theme'].includes(key) ? value => {
	            if (is_function(value)) {
	              let result = value(defOpts[key]);
	              opts[key] = result;
	              set(set === _set ? result : value);
	            } else {
	              opts[key] = value;
	              set(value);
	            }
	          } : value => {
	            opts[key] = value;
	            set(value);
	          },
	          _set,
	          ...rest
	        };
	      }
	      // When view changes...
	      this.view.subscribe(newView => {
	        if (newView === view) {
	          // switch view component
	          this._viewComponent.set(component);
	          if (is_function(opts.viewDidMount)) {
	            tick().then(() => opts.viewDidMount(get_store_value(this._view)));
	          }
	          // update store values
	          for (let key of keys(opts)) {
	            this[key]._set(opts[key]);
	          }
	        }
	      });
	    }
	  }
	}
	function parseOpts(opts, parsers) {
	  let result = {
	    ...opts
	  };
	  for (let key of keys(parsers)) {
	    if (key in result) {
	      result[key] = parsers[key](result[key]);
	    }
	  }
	  if (opts.views) {
	    result.views = {};
	    for (let view of keys(opts.views)) {
	      result.views[view] = parseOpts(opts.views[view], parsers);
	    }
	  }
	  return result;
	}
	function mergeOpts() {
	  let result = {};
	  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }
	  for (let opts of args) {
	    let override = {};
	    for (let key of ['buttonText', 'theme']) {
	      if (is_function(opts[key])) {
	        override[key] = opts[key](result[key]);
	      }
	    }
	    result = {
	      ...result,
	      ...opts,
	      ...override
	    };
	  }
	  return result;
	}
	function filterOpts(opts, state) {
	  keys(opts).filter(key => !validKey(key, state) || key == 'view').forEach(key => delete opts[key]);
	}
	function validKey(key, state) {
	  return state.hasOwnProperty(key) && key[0] !== '_';
	}

	/* packages/core/src/Buttons.svelte generated by Svelte v4.2.8 */

	function get_each_context$2$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[23] = list[i];
	  return child_ctx;
	}

	// (52:27) 
	function create_if_block_4$1(ctx) {
	  let button_1;
	  let t_value = /*$buttonText*/ctx[5][/*button*/ctx[23]] + "";
	  let t;
	  let button_1_class_value;
	  let mounted;
	  let dispose;
	  function click_handler_1() {
	    return /*click_handler_1*/ctx[20]( /*button*/ctx[23]);
	  }
	  return {
	    c() {
	      button_1 = element("button");
	      t = text(t_value);
	      attr(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + ( /*$view*/ctx[6] === /*button*/ctx[23] ? ' ' + /*$theme*/ctx[3].active : '') + " ec-" + /*button*/ctx[23]));
	    },
	    m(target, anchor) {
	      insert(target, button_1, anchor);
	      append(button_1, t);
	      if (!mounted) {
	        dispose = listen(button_1, "click", click_handler_1);
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$buttonText, buttons*/33 && t_value !== (t_value = /*$buttonText*/ctx[5][/*button*/ctx[23]] + "")) set_data(t, t_value);
	      if (dirty & /*$theme, $view, buttons*/73 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + ( /*$view*/ctx[6] === /*button*/ctx[23] ? ' ' + /*$theme*/ctx[3].active : '') + " ec-" + /*button*/ctx[23]))) {
	        attr(button_1, "class", button_1_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (46:32) 
	function create_if_block_3$3(ctx) {
	  let button_1;
	  let t_value = /*$buttonText*/ctx[5][/*button*/ctx[23]] + "";
	  let t;
	  let button_1_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      button_1 = element("button");
	      t = text(t_value);
	      attr(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]));
	      button_1.disabled = /*isToday*/ctx[1];
	    },
	    m(target, anchor) {
	      insert(target, button_1, anchor);
	      append(button_1, t);
	      if (!mounted) {
	        dispose = listen(button_1, "click", /*click_handler*/ctx[19]);
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$buttonText, buttons*/33 && t_value !== (t_value = /*$buttonText*/ctx[5][/*button*/ctx[23]] + "")) set_data(t, t_value);
	      if (dirty & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]))) {
	        attr(button_1, "class", button_1_class_value);
	      }
	      if (dirty & /*isToday*/2) {
	        button_1.disabled = /*isToday*/ctx[1];
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (39:31) 
	function create_if_block_2$4(ctx) {
	  let button_1;
	  let i;
	  let i_class_value;
	  let button_1_class_value;
	  let button_1_aria_label_value;
	  let button_1_title_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      button_1 = element("button");
	      i = element("i");
	      attr(i, "class", i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[23]));
	      attr(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]));
	      attr(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/ctx[5].next);
	      attr(button_1, "title", button_1_title_value = /*$buttonText*/ctx[5].next);
	    },
	    m(target, anchor) {
	      insert(target, button_1, anchor);
	      append(button_1, i);
	      if (!mounted) {
	        dispose = listen(button_1, "click", /*next*/ctx[17]);
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme, buttons*/9 && i_class_value !== (i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[23]))) {
	        attr(i, "class", i_class_value);
	      }
	      if (dirty & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]))) {
	        attr(button_1, "class", button_1_class_value);
	      }
	      if (dirty & /*$buttonText*/32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/ctx[5].next)) {
	        attr(button_1, "aria-label", button_1_aria_label_value);
	      }
	      if (dirty & /*$buttonText*/32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/ctx[5].next)) {
	        attr(button_1, "title", button_1_title_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (32:31) 
	function create_if_block_1$4(ctx) {
	  let button_1;
	  let i;
	  let i_class_value;
	  let button_1_class_value;
	  let button_1_aria_label_value;
	  let button_1_title_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      button_1 = element("button");
	      i = element("i");
	      attr(i, "class", i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[23]));
	      attr(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]));
	      attr(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/ctx[5].prev);
	      attr(button_1, "title", button_1_title_value = /*$buttonText*/ctx[5].prev);
	    },
	    m(target, anchor) {
	      insert(target, button_1, anchor);
	      append(button_1, i);
	      if (!mounted) {
	        dispose = listen(button_1, "click", /*prev*/ctx[16]);
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme, buttons*/9 && i_class_value !== (i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[23]))) {
	        attr(i, "class", i_class_value);
	      }
	      if (dirty & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[23]))) {
	        attr(button_1, "class", button_1_class_value);
	      }
	      if (dirty & /*$buttonText*/32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/ctx[5].prev)) {
	        attr(button_1, "aria-label", button_1_aria_label_value);
	      }
	      if (dirty & /*$buttonText*/32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/ctx[5].prev)) {
	        attr(button_1, "title", button_1_title_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (29:4) {#if button == 'title'}
	function create_if_block$1$3(ctx) {
	  let h2;
	  let h2_class_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      h2 = element("h2");
	      attr(h2, "class", h2_class_value = /*$theme*/ctx[3].title);
	    },
	    m(target, anchor) {
	      insert(target, h2, anchor);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, h2, /*$_viewTitle*/ctx[4]));
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme*/8 && h2_class_value !== (h2_class_value = /*$theme*/ctx[3].title)) {
	        attr(h2, "class", h2_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_viewTitle*/16) setContent_action.update.call(null, /*$_viewTitle*/ctx[4]);
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(h2);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (28:0) {#each buttons as button}
	function create_each_block$2$3(ctx) {
	  let if_block_anchor;
	  function select_block_type(ctx, dirty) {
	    if ( /*button*/ctx[23] == 'title') return create_if_block$1$3;
	    if ( /*button*/ctx[23] == 'prev') return create_if_block_1$4;
	    if ( /*button*/ctx[23] == 'next') return create_if_block_2$4;
	    if ( /*button*/ctx[23] == 'today') return create_if_block_3$3;
	    if ( /*button*/ctx[23] != '') return create_if_block_4$1;
	  }
	  let current_block_type = select_block_type(ctx);
	  let if_block = current_block_type && current_block_type(ctx);
	  return {
	    c() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	    },
	    p(ctx, dirty) {
	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if (if_block) if_block.d(1);
	        if_block = current_block_type && current_block_type(ctx);
	        if (if_block) {
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if (if_block) {
	        if_block.d(detaching);
	      }
	    }
	  };
	}
	function create_fragment$3$5(ctx) {
	  let each_1_anchor;
	  let each_value = ensure_array_like( /*buttons*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$2$3(get_each_context$2$3(ctx, each_value, i));
	  }
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	    },
	    p(ctx, _ref7) {
	      let [dirty] = _ref7;
	      if (dirty & /*$theme, $_viewTitle, buttons, $buttonText, prev, next, isToday, $date, today, $view*/229503) {
	        each_value = ensure_array_like( /*buttons*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$2$3(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$2$3(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$3$5($$self, $$props, $$invalidate) {
	  let $duration;
	  let $date;
	  let $hiddenDays;
	  let $_currentRange;
	  let $theme;
	  let $_viewTitle;
	  let $buttonText;
	  let $view;
	  let {
	    buttons
	  } = $$props;
	  let {
	    _currentRange,
	    _viewTitle,
	    buttonText,
	    date,
	    duration,
	    hiddenDays,
	    theme,
	    view
	  } = getContext('state');
	  component_subscribe($$self, _currentRange, value => $$invalidate(18, $_currentRange = value));
	  component_subscribe($$self, _viewTitle, value => $$invalidate(4, $_viewTitle = value));
	  component_subscribe($$self, buttonText, value => $$invalidate(5, $buttonText = value));
	  component_subscribe($$self, date, value => $$invalidate(2, $date = value));
	  component_subscribe($$self, duration, value => $$invalidate(21, $duration = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(22, $hiddenDays = value));
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  component_subscribe($$self, view, value => $$invalidate(6, $view = value));
	  let today = setMidnight(createDate()),
	    isToday;
	  function prev() {
	    let d = subtractDuration($date, $duration);
	    if ($hiddenDays.length && $hiddenDays.length < 7) {
	      while ($hiddenDays.includes(d.getUTCDay())) {
	        subtractDay(d);
	      }
	    }
	    set_store_value(date, $date = d, $date);
	  }
	  function next() {
	    set_store_value(date, $date = addDuration($date, $duration), $date);
	  }
	  const click_handler = () => set_store_value(date, $date = cloneDate(today), $date);
	  const click_handler_1 = button => set_store_value(view, $view = button, $view);
	  $$self.$$set = $$props => {
	    if ('buttons' in $$props) $$invalidate(0, buttons = $$props.buttons);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_currentRange*/262144) {
	      $$invalidate(1, isToday = today >= $_currentRange.start && today < $_currentRange.end || null);
	    }
	  };
	  return [buttons, isToday, $date, $theme, $_viewTitle, $buttonText, $view, _currentRange, _viewTitle, buttonText, date, duration, hiddenDays, theme, view, today, prev, next, $_currentRange, click_handler, click_handler_1];
	}
	class Buttons extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3$5, create_fragment$3$5, safe_not_equal, {
	      buttons: 0
	    });
	  }
	}

	/* packages/core/src/Toolbar.svelte generated by Svelte v4.2.8 */

	function get_each_context$1$4(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[5] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[8] = list[i];
	  return child_ctx;
	}

	// (28:16) {:else}
	function create_else_block$2(ctx) {
	  let buttons_1;
	  let current;
	  buttons_1 = new Buttons({
	    props: {
	      buttons: /*buttons*/ctx[8]
	    }
	  });
	  return {
	    c() {
	      create_component(buttons_1.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(buttons_1, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const buttons_1_changes = {};
	      if (dirty & /*sections*/1) buttons_1_changes.buttons = /*buttons*/ctx[8];
	      buttons_1.$set(buttons_1_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(buttons_1.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(buttons_1.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(buttons_1, detaching);
	    }
	  };
	}

	// (24:16) {#if buttons.length > 1}
	function create_if_block$7(ctx) {
	  let div;
	  let buttons_1;
	  let div_class_value;
	  let current;
	  buttons_1 = new Buttons({
	    props: {
	      buttons: /*buttons*/ctx[8]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(buttons_1.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[1].buttonGroup);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(buttons_1, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const buttons_1_changes = {};
	      if (dirty & /*sections*/1) buttons_1_changes.buttons = /*buttons*/ctx[8];
	      buttons_1.$set(buttons_1_changes);
	      if (!current || dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].buttonGroup)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(buttons_1.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(buttons_1.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(buttons_1);
	    }
	  };
	}

	// (23:12) {#each sections[key] as buttons}
	function create_each_block_1$3(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block$7, create_else_block$2];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*buttons*/ctx[8].length > 1) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	}

	// (21:4) {#each Object.keys(sections) as key}
	function create_each_block$1$4(ctx) {
	  let div;
	  let t;
	  let current;
	  let each_value_1 = ensure_array_like( /*sections*/ctx[0][/*key*/ctx[5]]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append(div, t);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme, sections, Object*/3) {
	        each_value_1 = ensure_array_like( /*sections*/ctx[0][/*key*/ctx[5]]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1$3(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1$3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$2$5(ctx) {
	  let nav;
	  let nav_class_value;
	  let current;
	  let each_value = ensure_array_like(Object.keys( /*sections*/ctx[0]));
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1$4(get_each_context$1$4(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      nav = element("nav");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(nav, "class", nav_class_value = /*$theme*/ctx[1].toolbar);
	    },
	    m(target, anchor) {
	      insert(target, nav, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(nav, null);
	        }
	      }
	      current = true;
	    },
	    p(ctx, _ref8) {
	      let [dirty] = _ref8;
	      if (dirty & /*sections, Object, $theme*/3) {
	        each_value = ensure_array_like(Object.keys( /*sections*/ctx[0]));
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1$4(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1$4(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(nav, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/2 && nav_class_value !== (nav_class_value = /*$theme*/ctx[1].toolbar)) {
	        attr(nav, "class", nav_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(nav);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$2$6($$self, $$props, $$invalidate) {
	  let $headerToolbar;
	  let $theme;
	  let {
	    headerToolbar,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, headerToolbar, value => $$invalidate(4, $headerToolbar = value));
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  let sections = {
	    start: [],
	    center: [],
	    end: []
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*sections, $headerToolbar*/17) {
	      {
	        for (let key of Object.keys(sections)) {
	          $$invalidate(0, sections[key] = $headerToolbar[key].split(' ').map(group => group.split(',')), sections);
	        }
	      }
	    }
	  };
	  return [sections, $theme, headerToolbar, theme, $headerToolbar];
	}
	class Toolbar extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$6, create_fragment$2$5, safe_not_equal, {});
	  }
	}

	/* packages/core/src/Auxiliary.svelte generated by Svelte v4.2.8 */

	function get_each_context$a(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[11] = list[i];
	  return child_ctx;
	}

	// (25:0) {#each $_auxiliary as component}
	function create_each_block$a(ctx) {
	  let switch_instance;
	  let switch_instance_anchor;
	  let current;
	  var switch_value = /*component*/ctx[11];
	  function switch_props(ctx, dirty) {
	    return {};
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props());
	  }
	  return {
	    c() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m(target, anchor) {
	      if (switch_instance) mount_component(switch_instance, target, anchor);
	      insert(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$_auxiliary*/1 && switch_value !== (switch_value = /*component*/ctx[11])) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      }
	    },
	    i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(switch_instance_anchor);
	      }
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	}
	function create_fragment$1$6(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*$_auxiliary*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, _ref9) {
	      let [dirty] = _ref9;
	      if (dirty & /*$_auxiliary*/1) {
	        each_value = ensure_array_like( /*$_auxiliary*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$a(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$a(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$1$6($$self, $$props, $$invalidate) {
	  let $_view;
	  let $datesSet;
	  let $_activeRange;
	  let $_auxiliary;
	  let {
	    datesSet,
	    _auxiliary,
	    _activeRange,
	    _queue,
	    _view
	  } = getContext('state');
	  component_subscribe($$self, datesSet, value => $$invalidate(7, $datesSet = value));
	  component_subscribe($$self, _auxiliary, value => $$invalidate(0, $_auxiliary = value));
	  component_subscribe($$self, _activeRange, value => $$invalidate(5, $_activeRange = value));
	  component_subscribe($$self, _view, value => $$invalidate(6, $_view = value));
	  let debounceHandle = {};
	  function runDatesSet(_activeRange) {
	    if (is_function($datesSet)) {
	      debounce(() => $datesSet({
	        start: toLocalDate(_activeRange.start),
	        end: toLocalDate(_activeRange.end),
	        startStr: toISOString(_activeRange.start),
	        endStr: toISOString(_activeRange.end),
	        view: toViewWithLocalDates($_view)
	      }), debounceHandle, _queue);
	    }
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_activeRange*/32) {
	      // Set up datesSet callback
	      runDatesSet($_activeRange);
	    }
	  };
	  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
	}
	let Auxiliary$2 = class Auxiliary extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$6, create_fragment$1$6, safe_not_equal, {});
	  }
	};

	/* packages/core/src/Calendar.svelte generated by Svelte v4.2.8 */

	function create_fragment$d(ctx) {
	  let div;
	  let toolbar;
	  let t0;
	  let switch_instance;
	  let div_class_value;
	  let div_role_value;
	  let t1;
	  let auxiliary;
	  let current;
	  let mounted;
	  let dispose;
	  toolbar = new Toolbar({});
	  var switch_value = /*$_viewComponent*/ctx[5];
	  function switch_props(ctx, dirty) {
	    return {};
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props());
	  }
	  auxiliary = new Auxiliary$2({});
	  return {
	    c() {
	      div = element("div");
	      create_component(toolbar.$$.fragment);
	      t0 = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      t1 = space();
	      create_component(auxiliary.$$.fragment);
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[1].calendar + " " + /*$theme*/ctx[1].view + ( /*$_scrollable*/ctx[0] ? ' ' + /*$theme*/ctx[1].withScroll : '') + ( /*$_iClass*/ctx[2] ? ' ' + /*$theme*/ctx[1][/*$_iClass*/ctx[2]] : '')));
	      attr(div, "role", div_role_value = listView( /*$view*/ctx[4]) ? 'list' : 'table');
	      set_style(div, "height", /*$height*/ctx[3]);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(toolbar, div, null);
	      append(div, t0);
	      if (switch_instance) mount_component(switch_instance, div, null);
	      insert(target, t1, anchor);
	      mount_component(auxiliary, target, anchor);
	      current = true;
	      if (!mounted) {
	        dispose = listen(window, "resize", /*recheckScrollable*/ctx[16]);
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$_viewComponent*/32 && switch_value !== (switch_value = /*$_viewComponent*/ctx[5])) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, div, null);
	        } else {
	          switch_instance = null;
	        }
	      }
	      if (!current || dirty[0] & /*$theme, $_scrollable, $_iClass*/7 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[1].calendar + " " + /*$theme*/ctx[1].view + ( /*$_scrollable*/ctx[0] ? ' ' + /*$theme*/ctx[1].withScroll : '') + ( /*$_iClass*/ctx[2] ? ' ' + /*$theme*/ctx[1][/*$_iClass*/ctx[2]] : '')))) {
	        attr(div, "class", div_class_value);
	      }
	      if (!current || dirty[0] & /*$view*/16 && div_role_value !== (div_role_value = listView( /*$view*/ctx[4]) ? 'list' : 'table')) {
	        attr(div, "role", div_role_value);
	      }
	      if (dirty[0] & /*$height*/8) {
	        set_style(div, "height", /*$height*/ctx[3]);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(toolbar.$$.fragment, local);
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      transition_in(auxiliary.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(toolbar.$$.fragment, local);
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      transition_out(auxiliary.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	        detach(t1);
	      }
	      destroy_component(toolbar);
	      if (switch_instance) destroy_component(switch_instance);
	      destroy_component(auxiliary, detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function instance$d($$self, $$props, $$invalidate) {
	  let $_bodyEl;
	  let $_scrollable;
	  let $_queue;
	  let $_interaction;
	  let $_events;
	  let $theme;
	  let $_iClass;
	  let $height;
	  let $view;
	  let $_viewComponent;
	  let {
	    plugins = []
	  } = $$props;
	  let {
	    options = {}
	  } = $$props;
	  let component = get_current_component();
	  let state = new State(plugins, options);
	  setContext('state', state);
	  let {
	    _viewComponent,
	    _bodyEl,
	    _interaction,
	    _iClass,
	    _events,
	    _queue,
	    _scrollable,
	    height,
	    theme,
	    view
	  } = state;
	  component_subscribe($$self, _viewComponent, value => $$invalidate(5, $_viewComponent = value));
	  component_subscribe($$self, _bodyEl, value => $$invalidate(31, $_bodyEl = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(33, $_interaction = value));
	  component_subscribe($$self, _iClass, value => $$invalidate(2, $_iClass = value));
	  component_subscribe($$self, _events, value => $$invalidate(34, $_events = value));
	  component_subscribe($$self, _queue, value => $$invalidate(32, $_queue = value));
	  component_subscribe($$self, _scrollable, value => $$invalidate(0, $_scrollable = value));
	  component_subscribe($$self, height, value => $$invalidate(3, $height = value));
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  component_subscribe($$self, view, value => $$invalidate(4, $view = value));

	  // Reactively update options that did change
	  let prevOptions = {
	    ...options
	  };
	  function setOption(name, value) {
	    state._set(name, value);
	    return this;
	  }
	  function getOption(name) {
	    let value = state._get(name);
	    return value instanceof Date ? toLocalDate(value) : value;
	  }
	  function refetchEvents() {
	    state._fetchedRange.set({
	      start: undefined,
	      end: undefined
	    });
	    return this;
	  }
	  function getEvents() {
	    return $_events.map(toEventWithLocalDates);
	  }
	  function getEventById(id) {
	    for (let event of $_events) {
	      if (event.id == id) {
	        return toEventWithLocalDates(event);
	      }
	    }
	    return null;
	  }
	  function addEvent(event) {
	    $_events.push(createEvents([event])[0]);
	    _events.set($_events);
	    return this;
	  }
	  function updateEvent(event) {
	    for (let e of $_events) {
	      if (e.id == event.id) {
	        assign(e, createEvents([event])[0]);
	        _events.set($_events);
	        break;
	      }
	    }
	    return this;
	  }
	  function removeEventById(id) {
	    let idx = $_events.findIndex(event => event.id == id);
	    if (idx >= 0) {
	      $_events.splice(idx, 1);
	      _events.set($_events);
	    }
	    return this;
	  }
	  function getView() {
	    return toViewWithLocalDates(get_store_value(state._view));
	  }
	  function unselect() {
	    if ($_interaction.action) {
	      $_interaction.action.unselect();
	    }
	    return this;
	  }
	  function dateFromPoint(x, y) {
	    let dayEl = getElementWithPayload(x, y);
	    return dayEl ? getPayload(dayEl)(y) : null;
	  }
	  function destroy() {
	    destroy_component(component, true);
	  }
	  beforeUpdate(() => {
	    flushDebounce($_queue);
	    setTimeout(recheckScrollable);
	  });
	  function recheckScrollable() {
	    if ($_bodyEl) {
	      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
	    }
	  }
	  $$self.$$set = $$props => {
	    if ('plugins' in $$props) $$invalidate(17, plugins = $$props.plugins);
	    if ('options' in $$props) $$invalidate(18, options = $$props.options);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*options*/262144) {
	      for (let [name, value] of diff(options, prevOptions)) {
	        setOption(name, value);
	      }
	    }
	  };
	  return [$_scrollable, $theme, $_iClass, $height, $view, $_viewComponent, _viewComponent, _bodyEl, _interaction, _iClass, _events, _queue, _scrollable, height, theme, view, recheckScrollable, plugins, options, setOption, getOption, refetchEvents, getEvents, getEventById, addEvent, updateEvent, removeEventById, getView, unselect, dateFromPoint, destroy];
	}
	class Calendar extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$d, create_fragment$d, safe_not_equal, {
	      plugins: 17,
	      options: 18,
	      setOption: 19,
	      getOption: 20,
	      refetchEvents: 21,
	      getEvents: 22,
	      getEventById: 23,
	      addEvent: 24,
	      updateEvent: 25,
	      removeEventById: 26,
	      getView: 27,
	      unselect: 28,
	      dateFromPoint: 29,
	      destroy: 30
	    }, null, [-1, -1]);
	  }
	  get setOption() {
	    return this.$$.ctx[19];
	  }
	  get getOption() {
	    return this.$$.ctx[20];
	  }
	  get refetchEvents() {
	    return this.$$.ctx[21];
	  }
	  get getEvents() {
	    return this.$$.ctx[22];
	  }
	  get getEventById() {
	    return this.$$.ctx[23];
	  }
	  get addEvent() {
	    return this.$$.ctx[24];
	  }
	  get updateEvent() {
	    return this.$$.ctx[25];
	  }
	  get removeEventById() {
	    return this.$$.ctx[26];
	  }
	  get getView() {
	    return this.$$.ctx[27];
	  }
	  get unselect() {
	    return this.$$.ctx[28];
	  }
	  get dateFromPoint() {
	    return this.$$.ctx[29];
	  }
	  get destroy() {
	    return this.$$.ctx[30];
	  }
	}

	function days$1(state) {
	  return derived([state.date, state.firstDay, state.hiddenDays], _ref => {
	    let [$date, $firstDay, $hiddenDays] = _ref;
	    let days = [];
	    let day = cloneDate($date);
	    let max = 7;
	    // First day of week
	    while (day.getUTCDay() !== $firstDay && max) {
	      subtractDay(day);
	      --max;
	    }
	    for (let i = 0; i < 7; ++i) {
	      if (!$hiddenDays.includes(day.getUTCDay())) {
	        days.push(cloneDate(day));
	      }
	      addDay(day);
	    }
	    return days;
	  });
	}

	/* packages/day-grid/src/Header.svelte generated by Svelte v4.2.8 */

	function get_each_context$4$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[8] = list[i];
	  return child_ctx;
	}

	// (10:8) {#each $_days as day}
	function create_each_block$4$2(ctx) {
	  let div;
	  let span;
	  let span_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      span = element("span");
	      t = space();
	      attr(span, "aria-label", span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]));
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]));
	      attr(div, "role", "columnheader");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, span);
	      append(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, span, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8])));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$_intlDayHeaderAL, $_days*/6 && span_aria_label_value !== (span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]))) {
	        attr(span, "aria-label", span_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_days*/10) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8]));
	      if (dirty & /*$theme, $_days*/3 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function create_fragment$6$2(ctx) {
	  let div2;
	  let div0;
	  let div0_class_value;
	  let t;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let each_value = ensure_array_like( /*$_days*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4$2(get_each_context$4$2(ctx, each_value, i));
	  }
	  return {
	    c() {
	      div2 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      div1 = element("div");
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].days);
	      attr(div0, "role", "row");
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].hiddenScroll);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[0].header);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append(div2, t);
	      append(div2, div1);
	    },
	    p(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if (dirty & /*$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader*/15) {
	        each_value = ensure_array_like( /*$_days*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$4$2(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$4$2(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(div0, null);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	      if (dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].days)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (dirty & /*$theme*/1 && div2_class_value !== (div2_class_value = /*$theme*/ctx[0].header)) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$6$2($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_days;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let {
	    theme,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    _days
	  } = getContext('state');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(2, $_intlDayHeaderAL = value));
	  component_subscribe($$self, _days, value => $$invalidate(1, $_days = value));
	  return [$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader, theme, _intlDayHeader, _intlDayHeaderAL, _days];
	}
	let Header$1 = class Header extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$6$2, create_fragment$6$2, safe_not_equal, {});
	  }
	};

	/* packages/day-grid/src/Body.svelte generated by Svelte v4.2.8 */

	function create_fragment$5$2(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  const default_slot_template = /*#slots*/ctx[7].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[6], null);
	  return {
	    c() {
	      div1 = element("div");
	      div0 = element("div");
	      if (default_slot) default_slot.c();
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].content);
	      attr(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')));
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      if (default_slot) {
	        default_slot.m(div0, null);
	      }

	      /*div1_binding*/
	      ctx[8](div1);
	      current = true;
	    },
	    p(ctx, _ref3) {
	      let [dirty] = _ref3;
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/64)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[6], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[6]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[6], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].content)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, $dayMaxEvents*/3 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')))) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	      }
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/
	      ctx[8](null);
	    }
	  };
	}
	function instance$5$2($$self, $$props, $$invalidate) {
	  let $theme;
	  let $dayMaxEvents;
	  let $_bodyEl;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  let {
	    dayMaxEvents,
	    _bodyEl,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(1, $dayMaxEvents = value));
	  component_subscribe($$self, _bodyEl, value => $$invalidate(2, $_bodyEl = value));
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_bodyEl = $$value;
	      _bodyEl.set($_bodyEl);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	  };
	  return [$theme, $dayMaxEvents, $_bodyEl, dayMaxEvents, _bodyEl, theme, $$scope, slots, div1_binding];
	}
	let Body$3 = class Body extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$5$2, create_fragment$5$2, safe_not_equal, {});
	  }
	};

	/* packages/day-grid/src/Event.svelte generated by Svelte v4.2.8 */

	function create_fragment$4$3(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[8].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      }
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	    });
	  }
	  return {
	    c() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      attr(article, "class", /*classes*/ctx[4]);
	      attr(article, "style", /*style*/ctx[5]);
	      attr(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	    },
	    m(target, anchor) {
	      insert(target, article, anchor);
	      append(article, div);
	      append(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[51](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }), listen(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }), listen(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[31]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[31]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[31]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]))) /*createHandler*/ctx[31]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "pointerdown", function () {
	          if (is_function(!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8]))) (!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8])).apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/256 && switch_value !== (switch_value = /*$_interaction*/ctx[8].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[51](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$4$3($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_hiddenEvents;
	  let $dayMaxEvents;
	  let $_popupDate;
	  let $_interaction;
	  let $_view;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let {
	    chunk
	  } = $$props;
	  let {
	    longChunks = {}
	  } = $$props;
	  let {
	    inPopup = false
	  } = $$props;
	  let {
	    dayMaxEvents,
	    displayEventEnd,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _hiddenEvents,
	    _popupDate
	  } = getContext('state');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(54, $dayMaxEvents = value));
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(43, $displayEventEnd = value));
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(49, $eventBackgroundColor = value));
	  component_subscribe($$self, eventTextColor, value => $$invalidate(46, $eventTextColor = value));
	  component_subscribe($$self, eventClick, value => $$invalidate(39, $eventClick = value));
	  component_subscribe($$self, eventColor, value => $$invalidate(48, $eventColor = value));
	  component_subscribe($$self, eventContent, value => $$invalidate(42, $eventContent = value));
	  component_subscribe($$self, eventClassNames, value => $$invalidate(44, $eventClassNames = value));
	  component_subscribe($$self, eventDidMount, value => $$invalidate(56, $eventDidMount = value));
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  component_subscribe($$self, _view, value => $$invalidate(40, $_view = value));
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(41, $_intlEventTime = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  component_subscribe($$self, _iClasses, value => $$invalidate(45, $_iClasses = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(50, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(47, $_resTxtColor = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(53, $_hiddenEvents = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(55, $_popupDate = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let margin = 1;
	  let hidden = false;
	  let display;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => $_interaction.action.drag(event, jsEvent, resize, inPopup ? $_popupDate : undefined) : undefined;
	  }
	  function reposition() {
	    if (!el || previewEvent(display) || inPopup) {
	      return;
	    }
	    $$invalidate(37, margin = repositionEvent(chunk, longChunks, height(el)));
	    if ($dayMaxEvents === true) {
	      hide();
	    } else {
	      $$invalidate(38, hidden = false);
	    }
	  }
	  function hide() {
	    let dayEl = ancestor(el, 2);
	    let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
	    $$invalidate(38, hidden = chunk.bottom > h);
	    let update = false;

	    // Hide or show the event throughout all days
	    for (let date of chunk.dates) {
	      let hiddenEvents = $_hiddenEvents[date.getTime()];
	      if (hiddenEvents) {
	        let size = hiddenEvents.size;
	        if (hidden) {
	          hiddenEvents.add(chunk.event);
	        } else {
	          hiddenEvents.delete(chunk.event);
	        }
	        if (size !== hiddenEvents.size) {
	          update = true;
	        }
	      }
	    }
	    if (update) {
	      _hiddenEvents.set($_hiddenEvents);
	    }
	  }
	  function footHeight(dayEl) {
	    let h = 0;
	    for (let i = 0; i < chunk.days; ++i) {
	      h = max(h, height(dayEl.lastElementChild));
	      dayEl = dayEl.nextElementSibling;
	      if (!dayEl) {
	        break;
	      }
	    }
	    return h;
	  }
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(33, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(34, longChunks = $$props.longChunks);
	    if ('inPopup' in $$props) $$invalidate(35, inPopup = $$props.inPopup);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/4) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme*/37 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, chunk, margin, hidden, $_iClasses, $eventClassNames, $_view*/1041092) {
	      {
	        $$invalidate(1, display = event.display);

	        // Class & Style
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        if (hidden) {
	          $$invalidate(5, style += 'visibility:hidden;');
	        }
	        $$invalidate(4, classes = [$theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/7684) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/256) {
	      // Onclick handler
	      $$invalidate(7, onclick = createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $_interaction, $eventMouseEnter, $eventMouseLeave, dayMaxEvents, displayEventEnd, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _hiddenEvents, _popupDate, createHandler, createDragHandler, chunk, longChunks, inPopup, reposition, margin, hidden, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	let Event$4 = class Event extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$4$3, create_fragment$4$3, safe_not_equal, {
	      chunk: 33,
	      longChunks: 34,
	      inPopup: 35,
	      reposition: 36
	    }, null, [-1, -1]);
	  }
	  get reposition() {
	    return this.$$.ctx[36];
	  }
	};

	/* packages/day-grid/src/Popup.svelte generated by Svelte v4.2.8 */

	function get_each_context$3$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	// (100:8) {#each $_popupChunks as chunk (chunk.event)}
	function create_each_block$3$2(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$4({
	    props: {
	      chunk: /*chunk*/ctx[20],
	      inPopup: true
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty & /*$_popupChunks*/1) event_changes.chunk = /*chunk*/ctx[20];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	}
	function create_fragment$3$4(ctx) {
	  let div2;
	  let div0;
	  let time;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let a;
	  let t1;
	  let a_aria_label_value;
	  let div0_class_value;
	  let t2;
	  let div1;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like( /*$_popupChunks*/ctx[0]);
	  const get_key = ctx => /*chunk*/ctx[20].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$3$2(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$3$2(key, child_ctx));
	  }
	  return {
	    c() {
	      div2 = element("div");
	      div0 = element("div");
	      time = element("time");
	      t0 = space();
	      a = element("a");
	      t1 = text("×");
	      t2 = space();
	      div1 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(time, "datetime", time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10));
	      attr(a, "role", "button");
	      attr(a, "tabindex", "0");
	      attr(a, "aria-label", a_aria_label_value = /*$buttonText*/ctx[6].close);
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[4].dayHead);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[4].events);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[4].popup);
	      attr(div2, "style", /*style*/ctx[2]);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      append(div0, time);
	      append(div0, t0);
	      append(div0, a);
	      append(a, t1);
	      append(div2, t2);
	      append(div2, div1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }

	      /*div2_binding*/
	      ctx[16](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]))), listen(a, "click", stop_propagation( /*close*/ctx[13])), listen(a, "keydown", keyEnter( /*close*/ctx[13])), action_destroyer(outsideEvent.call(null, div2, 'pointerdown')), listen(div2, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[15])), listen(div2, "pointerdownoutside", /*handlePointerDownOutside*/ctx[14])];
	        mounted = true;
	      }
	    },
	    p(ctx, _ref4) {
	      let [dirty] = _ref4;
	      if (!current || dirty & /*$_popupDate*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayPopover, $_popupDate*/40) setContent_action.update.call(null, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]));
	      if (!current || dirty & /*$buttonText*/64 && a_aria_label_value !== (a_aria_label_value = /*$buttonText*/ctx[6].close)) {
	        attr(a, "aria-label", a_aria_label_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div0_class_value !== (div0_class_value = /*$theme*/ctx[4].dayHead)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$_popupChunks*/1) {
	        each_value = ensure_array_like( /*$_popupChunks*/ctx[0]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$3$2, null, get_each_context$3$2);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/16 && div1_class_value !== (div1_class_value = /*$theme*/ctx[4].events)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div2_class_value !== (div2_class_value = /*$theme*/ctx[4].popup)) {
	        attr(div2, "class", div2_class_value);
	      }
	      if (!current || dirty & /*style*/4) {
	        attr(div2, "style", /*style*/ctx[2]);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div2_binding*/
	      ctx[16](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$3$4($$self, $$props, $$invalidate) {
	  let $_interaction;
	  let $_popupDate;
	  let $_popupChunks;
	  let $theme;
	  let $_intlDayPopover;
	  let $buttonText;
	  let {
	    buttonText,
	    theme,
	    _interaction,
	    _intlDayPopover,
	    _popupDate,
	    _popupChunks
	  } = getContext('state');
	  component_subscribe($$self, buttonText, value => $$invalidate(6, $buttonText = value));
	  component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(17, $_interaction = value));
	  component_subscribe($$self, _intlDayPopover, value => $$invalidate(5, $_intlDayPopover = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(3, $_popupDate = value));
	  component_subscribe($$self, _popupChunks, value => $$invalidate(0, $_popupChunks = value));
	  let el;
	  let style = '';
	  function position() {
	    let dayEl = ancestor(el, 1);
	    let bodyEl = ancestor(dayEl, 3);
	    let popupRect = rect(el);
	    let dayRect = rect(dayEl);
	    let bodyRect = rect(bodyEl);
	    $$invalidate(2, style = '');
	    let left;
	    if (popupRect.width >= bodyRect.width) {
	      left = bodyRect.left - dayRect.left;
	      let right = dayRect.right - bodyRect.right;
	      $$invalidate(2, style += `right:${right}px;`);
	    } else {
	      left = (dayRect.width - popupRect.width) / 2;
	      if (dayRect.left + left < bodyRect.left) {
	        left = bodyRect.left - dayRect.left;
	      } else if (dayRect.left + left + popupRect.width > bodyRect.right) {
	        left = bodyRect.right - dayRect.left - popupRect.width;
	      }
	    }
	    $$invalidate(2, style += `left:${left}px;`);
	    let top;
	    if (popupRect.height >= bodyRect.height) {
	      top = bodyRect.top - dayRect.top;
	      let bottom = dayRect.bottom - bodyRect.bottom;
	      $$invalidate(2, style += `bottom:${bottom}px;`);
	    } else {
	      top = (dayRect.height - popupRect.height) / 2;
	      if (dayRect.top + top < bodyRect.top) {
	        top = bodyRect.top - dayRect.top;
	      } else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
	        top = bodyRect.bottom - dayRect.top - popupRect.height;
	      }
	    }
	    $$invalidate(2, style += `top:${top}px;`);
	  }
	  function reposition() {
	    // Skip the first call (el is not defined at this time)
	    if (el) {
	      $$invalidate(2, style = '');

	      // Let chunks to update/mount then position the popup
	      tick().then(() => {
	        if ($_popupChunks.length) {
	          position();
	        } else {
	          close();
	        }
	      });
	    }
	  }
	  function close(e) {
	    set_store_value(_popupDate, $_popupDate = null, $_popupDate);
	  }
	  function handlePointerDownOutside(e) {
	    close();
	    $_interaction.action?.noClick();
	  }
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_popupChunks*/1) {
	      if ($_popupChunks) {
	        // Fire reposition only on popup chunks change
	        reposition();
	      }
	    }
	  };
	  return [$_popupChunks, el, style, $_popupDate, $theme, $_intlDayPopover, $buttonText, buttonText, theme, _interaction, _intlDayPopover, _popupDate, _popupChunks, close, handlePointerDownOutside, pointerdown_handler, div2_binding];
	}
	let Popup$1 = class Popup extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3$4, create_fragment$3$4, safe_not_equal, {});
	  }
	};

	/* packages/day-grid/src/Day.svelte generated by Svelte v4.2.8 */

	function get_each_context$2$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[43] = list[i];
	  child_ctx[44] = list;
	  child_ctx[45] = i;
	  return child_ctx;
	}

	// (120:4) {#if iChunks[1] && datesEqual(iChunks[1].date, date)}
	function create_if_block_3$2(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$4({
	    props: {
	      chunk: /*iChunks*/ctx[2][1]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[12].events);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][1];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = /*$theme*/ctx[12].events)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(event);
	    }
	  };
	}

	// (126:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
	function create_if_block_2$3(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$4({
	    props: {
	      chunk: /*iChunks*/ctx[2][0]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview));
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][0];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(event);
	    }
	  };
	}

	// (132:8) {#each dayChunks as chunk, i (chunk.event)}
	function create_each_block$2$2(key_1, ctx) {
	  let first;
	  let event;
	  let i = /*i*/ctx[45];
	  let current;
	  const assign_event = () => /*event_binding*/ctx[36](event, i);
	  const unassign_event = () => /*event_binding*/ctx[36](null, i);
	  let event_props = {
	    chunk: /*chunk*/ctx[43],
	    longChunks: /*longChunks*/ctx[1]
	  };
	  event = new Event$4({
	    props: event_props
	  });
	  assign_event();
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (i !== /*i*/ctx[45]) {
	        unassign_event();
	        i = /*i*/ctx[45];
	        assign_event();
	      }
	      const event_changes = {};
	      if (dirty[0] & /*dayChunks*/16) event_changes.chunk = /*chunk*/ctx[43];
	      if (dirty[0] & /*longChunks*/2) event_changes.longChunks = /*longChunks*/ctx[1];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      unassign_event();
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (136:4) {#if showPopup}
	function create_if_block_1$3(ctx) {
	  let popup;
	  let current;
	  popup = new Popup$1({});
	  return {
	    c() {
	      create_component(popup.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(popup, target, anchor);
	      current = true;
	    },
	    i(local) {
	      if (current) return;
	      transition_in(popup.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(popup.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(popup, detaching);
	    }
	  };
	}

	// (140:8) {#if hiddenEvents.size}
	function create_if_block$6(ctx) {
	  let a;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      a = element("a");
	      attr(a, "role", "button");
	      attr(a, "tabindex", "0");
	      attr(a, "aria-haspopup", "true");
	    },
	    m(target, anchor) {
	      insert(target, a, anchor);
	      if (!mounted) {
	        dispose = [listen(a, "click", stop_propagation( /*showMore*/ctx[26])), listen(a, "keydown", keyEnter( /*showMore*/ctx[26])), listen(a, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[35])), action_destroyer(setContent_action = setContent.call(null, a, /*moreLink*/ctx[6]))];
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/64) setContent_action.update.call(null, /*moreLink*/ctx[6]);
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(a);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function create_fragment$2$4(ctx) {
	  let div2;
	  let time;
	  let time_class_value;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	  let t1;
	  let show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	  let t2;
	  let div0;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div0_class_value;
	  let t3;
	  let t4;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let if_block0 = show_if_1 && create_if_block_3$2(ctx);
	  let if_block1 = show_if && create_if_block_2$3(ctx);
	  let each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	  const get_key = ctx => /*chunk*/ctx[43].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$2$2(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$2$2(key, child_ctx));
	  }
	  let if_block2 = /*showPopup*/ctx[7] && create_if_block_1$3();
	  let if_block3 = /*hiddenEvents*/ctx[5].size && create_if_block$6(ctx);
	  return {
	    c() {
	      div2 = element("div");
	      time = element("time");
	      t0 = space();
	      if (if_block0) if_block0.c();
	      t1 = space();
	      if (if_block1) if_block1.c();
	      t2 = space();
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();
	      div1 = element("div");
	      if (if_block3) if_block3.c();
	      attr(time, "class", time_class_value = /*$theme*/ctx[12].dayHead);
	      attr(time, "datetime", time_datetime_value = toISOString( /*date*/ctx[0], 10));
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[12].events);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[12].dayFoot);
	      attr(div2, "class", div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[8] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[9] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[10] ? ' ' + /*$theme*/ctx[12].highlight : '')));
	      attr(div2, "role", "cell");
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, time);
	      append(div2, t0);
	      if (if_block0) if_block0.m(div2, null);
	      append(div2, t1);
	      if (if_block1) if_block1.m(div2, null);
	      append(div2, t2);
	      append(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append(div2, t3);
	      if (if_block2) if_block2.m(div2, null);
	      append(div2, t4);
	      append(div2, div1);
	      if (if_block3) if_block3.m(div1, null);
	      /*div2_binding*/
	      ctx[37](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [listen(window, "resize", /*reposition*/ctx[27]), action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]))), listen(div2, "pointerenter", function () {
	          if (is_function( /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]))) /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]).apply(this, arguments);
	        }), listen(div2, "pointerleave", function () {
	          if (is_function( /*$_interaction*/ctx[13].pointer?.leave)) /*$_interaction*/ctx[13].pointer?.leave.apply(this, arguments);
	        }), listen(div2, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[13].action?.select)) /*$_interaction*/ctx[13].action?.select.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4096 && time_class_value !== (time_class_value = /*$theme*/ctx[12].dayHead)) {
	        attr(time, "class", time_class_value);
	      }
	      if (!current || dirty[0] & /*date*/1 && time_datetime_value !== (time_datetime_value = toISOString( /*date*/ctx[0], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayCell, date*/16385) setContent_action.update.call(null, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]));
	      if (dirty[0] & /*iChunks, date*/5) show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	      if (show_if_1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_3$2(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div2, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, () => {
	          if_block0 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*iChunks, date*/5) show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	      if (show_if) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_2$3(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div2, t2);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*dayChunks, longChunks, refs*/2066) {
	        each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2$2, null, get_each_context$2$2);
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div0_class_value !== (div0_class_value = /*$theme*/ctx[12].events)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if ( /*showPopup*/ctx[7]) {
	        if (if_block2) {
	          if (dirty[0] & /*showPopup*/128) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_1$3();
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div2, t4);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, () => {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	      if ( /*hiddenEvents*/ctx[5].size) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block$6(ctx);
	          if_block3.c();
	          if_block3.m(div1, null);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div1_class_value !== (div1_class_value = /*$theme*/ctx[12].dayFoot)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty[0] & /*$theme, date, isToday, otherMonth, highlight*/5889 && div2_class_value !== (div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[8] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[9] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[10] ? ' ' + /*$theme*/ctx[12].highlight : '')))) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      transition_in(if_block2);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      transition_out(if_block2);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      /*div2_binding*/
	      ctx[37](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$2$5($$self, $$props, $$invalidate) {
	  let $_hiddenEvents;
	  let $_popupChunks;
	  let $_popupDate;
	  let $moreLinkContent;
	  let $highlightedDates;
	  let $currentDate;
	  let $_today;
	  let $theme;
	  let $_interaction;
	  let $_intlDayCell;
	  let {
	    date
	  } = $$props;
	  let {
	    chunks
	  } = $$props;
	  let {
	    longChunks
	  } = $$props;
	  let {
	    iChunks = []
	  } = $$props;
	  let {
	    date: currentDate,
	    dayMaxEvents,
	    highlightedDates,
	    moreLinkContent,
	    theme,
	    _hiddenEvents,
	    _intlDayCell,
	    _popupDate,
	    _popupChunks,
	    _today,
	    _interaction,
	    _queue
	  } = getContext('state');
	  component_subscribe($$self, currentDate, value => $$invalidate(33, $currentDate = value));
	  component_subscribe($$self, highlightedDates, value => $$invalidate(32, $highlightedDates = value));
	  component_subscribe($$self, moreLinkContent, value => $$invalidate(31, $moreLinkContent = value));
	  component_subscribe($$self, theme, value => $$invalidate(12, $theme = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(29, $_hiddenEvents = value));
	  component_subscribe($$self, _intlDayCell, value => $$invalidate(14, $_intlDayCell = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(30, $_popupDate = value));
	  component_subscribe($$self, _popupChunks, value => $$invalidate(38, $_popupChunks = value));
	  component_subscribe($$self, _today, value => $$invalidate(34, $_today = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(13, $_interaction = value));
	  let el;
	  let dayChunks;
	  let isToday;
	  let otherMonth;
	  let highlight;
	  let hiddenEvents = new Set(); // hidden events of this day
	  let moreLink = '';
	  let showPopup;
	  let refs = [];
	  function createPointerEnterHandler(interaction) {
	    return interaction.pointer ? jsEvent => interaction.pointer.enterDayGrid(date, jsEvent) : undefined;
	  }
	  function showMore() {
	    set_store_value(_popupDate, $_popupDate = date, $_popupDate);
	  }
	  function setPopupChunks() {
	    let nextDay = addDay(cloneDate(date));
	    let chunks = dayChunks.concat(longChunks[date.getTime()]?.chunks || []);
	    set_store_value(_popupChunks, $_popupChunks = chunks.map(chunk => assign({}, chunk, createEventChunk(chunk.event, date, nextDay), {
	      days: 1,
	      dates: [date]
	    })).sort((a, b) => a.top - b.top), $_popupChunks);
	  }
	  function reposition() {
	    $$invalidate(11, refs.length = dayChunks.length, refs);
	    for (let ref of refs) {
	      ref?.reposition?.();
	    }
	  }
	  afterUpdate(reposition);
	  let debounceHandle = {};
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function event_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(11, refs);
	    });
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(28, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*hiddenEvents, chunks, date, dayChunks*/268435505) {
	      {
	        $$invalidate(4, dayChunks = []);
	        hiddenEvents.clear();
	        (($$invalidate(5, hiddenEvents), $$invalidate(28, chunks)), $$invalidate(0, date)), $$invalidate(4, dayChunks);
	        for (let chunk of chunks) {
	          if (datesEqual(chunk.date, date)) {
	            dayChunks.push(chunk);
	          } // if ($dayMaxEvents !== false && dayChunks.length > $dayMaxEvents) {
	          // 	chunk.hidden = true;
	        } // }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*date, hiddenEvents*/33) {
	      set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$_today*/8) {
	      $$invalidate(8, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/6) {
	      {
	        $$invalidate(9, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
	        $$invalidate(10, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_hiddenEvents, hiddenEvents, moreLink*/536871008 | $$self.$$.dirty[1] & /*$moreLinkContent*/1) {
	      if ($_hiddenEvents && hiddenEvents.size) {
	        // make Svelte update this block on $_hiddenEvents update
	        let text = '+' + hiddenEvents.size + ' more';
	        if ($moreLinkContent) {
	          $$invalidate(6, moreLink = is_function($moreLinkContent) ? $moreLinkContent({
	            num: hiddenEvents.size,
	            text
	          }) : $moreLinkContent);
	          if (typeof moreLink === 'string') {
	            $$invalidate(6, moreLink = {
	              html: moreLink
	            });
	          }
	        } else {
	          $$invalidate(6, moreLink = {
	            html: text
	          });
	        }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_popupDate, date*/1073741825) {
	      $$invalidate(7, showPopup = $_popupDate && datesEqual(date, $_popupDate));
	    }
	    if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/146) {
	      if (showPopup && longChunks && dayChunks) {
	        // Let chunks to reposition then set popup chunks
	        tick().then(setPopupChunks);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*el, date*/9) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource: undefined,
	          dayEl: el
	        }));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_hiddenEvents*/536870912) {
	      if ($_hiddenEvents) {
	        debounce(reposition, debounceHandle, _queue);
	      }
	    }
	  };
	  return [date, longChunks, iChunks, el, dayChunks, hiddenEvents, moreLink, showPopup, isToday, otherMonth, highlight, refs, $theme, $_interaction, $_intlDayCell, currentDate, highlightedDates, moreLinkContent, theme, _hiddenEvents, _intlDayCell, _popupDate, _popupChunks, _today, _interaction, createPointerEnterHandler, showMore, reposition, chunks, $_hiddenEvents, $_popupDate, $moreLinkContent, $highlightedDates, $currentDate, $_today, pointerdown_handler, event_binding, div2_binding];
	}
	let Day$4 = class Day extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$5, create_fragment$2$4, safe_not_equal, {
	      date: 0,
	      chunks: 28,
	      longChunks: 1,
	      iChunks: 2
	    }, null, [-1, -1]);
	  }
	};

	/* packages/day-grid/src/Week.svelte generated by Svelte v4.2.8 */

	function get_each_context$1$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[14] = list[i];
	  return child_ctx;
	}

	// (44:4) {#each dates as date}
	function create_each_block$1$3(ctx) {
	  let day;
	  let current;
	  day = new Day$4({
	    props: {
	      date: /*date*/ctx[14],
	      chunks: /*chunks*/ctx[1],
	      longChunks: /*longChunks*/ctx[2],
	      iChunks: /*iChunks*/ctx[3]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*dates*/1) day_changes.date = /*date*/ctx[14];
	      if (dirty & /*chunks*/2) day_changes.chunks = /*chunks*/ctx[1];
	      if (dirty & /*longChunks*/4) day_changes.longChunks = /*longChunks*/ctx[2];
	      if (dirty & /*iChunks*/8) day_changes.iChunks = /*iChunks*/ctx[3];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}
	function create_fragment$1$5(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let each_value = ensure_array_like( /*dates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1$3(get_each_context$1$3(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(div, "class", div_class_value = /*$theme*/ctx[4].days);
	      attr(div, "role", "row");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	    },
	    p(ctx, _ref5) {
	      let [dirty] = _ref5;
	      if (dirty & /*dates, chunks, longChunks, iChunks*/15) {
	        each_value = ensure_array_like( /*dates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1$3(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1$3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/16 && div_class_value !== (div_class_value = /*$theme*/ctx[4].days)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$1$5($$self, $$props, $$invalidate) {
	  let $hiddenDays;
	  let $_iEvents;
	  let $_events;
	  let $theme;
	  let {
	    dates
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    hiddenDays,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(13, $_events = value));
	  component_subscribe($$self, _iEvents, value => $$invalidate(12, $_iEvents = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(11, $hiddenDays = value));
	  component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	  let chunks,
	    longChunks,
	    iChunks = [];
	  let start;
	  let end;
	  $$self.$$set = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*dates*/1) {
	      {
	        $$invalidate(9, start = dates[0]);
	        $$invalidate(10, end = addDay(cloneDate(dates[dates.length - 1])));
	      }
	    }
	    if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/11778) {
	      {
	        $$invalidate(1, chunks = []);
	        for (let event of $_events) {
	          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        $$invalidate(2, longChunks = prepareEventChunks(chunks, $hiddenDays));
	      }
	    }
	    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/7680) {
	      $$invalidate(3, iChunks = $_iEvents.map(event => {
	        let chunk;
	        if (event && eventIntersects(event, start, end)) {
	          chunk = createEventChunk(event, start, end);
	          prepareEventChunks([chunk], $hiddenDays);
	        } else {
	          chunk = null;
	        }
	        return chunk;
	      }));
	    }
	  };
	  return [dates, chunks, longChunks, iChunks, $theme, _events, _iEvents, hiddenDays, theme, start, end, $hiddenDays, $_iEvents, $_events];
	}
	let Week$2 = class Week extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$5, create_fragment$1$5, safe_not_equal, {
	      dates: 0
	    });
	  }
	};

	/* packages/day-grid/src/View.svelte generated by Svelte v4.2.8 */

	function get_each_context$9(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}

	// (29:0) {#each weeks as dates}
	function create_each_block$9(ctx) {
	  let week;
	  let current;
	  week = new Week$2({
	    props: {
	      dates: /*dates*/ctx[10]
	    }
	  });
	  return {
	    c() {
	      create_component(week.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const week_changes = {};
	      if (dirty & /*weeks*/1) week_changes.dates = /*dates*/ctx[10];
	      week.$set(week_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	}

	// (28:0) <Body>
	function create_default_slot$5(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*weeks*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*weeks*/1) {
	        each_value = ensure_array_like( /*weeks*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$9(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$9(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$c(ctx) {
	  let header;
	  let t;
	  let body;
	  let current;
	  header = new Header$1({});
	  body = new Body$3({
	    props: {
	      $$slots: {
	        default: [create_default_slot$5]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      create_component(header.$$.fragment);
	      t = space();
	      create_component(body.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(header, target, anchor);
	      insert(target, t, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p(ctx, _ref6) {
	      let [dirty] = _ref6;
	      const body_changes = {};
	      if (dirty & /*$$scope, weeks*/8193) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(header.$$.fragment, local);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(header.$$.fragment, local);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(t);
	      }
	      destroy_component(header, detaching);
	      destroy_component(body, detaching);
	    }
	  };
	}
	function instance$c($$self, $$props, $$invalidate) {
	  let $_viewDates;
	  let $dayMaxEvents;
	  let $_hiddenEvents;
	  let $hiddenDays;
	  let {
	    _viewDates,
	    _hiddenEvents,
	    dayMaxEvents,
	    hiddenDays
	  } = getContext('state');
	  component_subscribe($$self, _viewDates, value => $$invalidate(6, $_viewDates = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(9, $_hiddenEvents = value));
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(7, $dayMaxEvents = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(8, $hiddenDays = value));
	  let weeks;
	  let days;
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$hiddenDays, $dayMaxEvents, $_viewDates, days, weeks*/481) {
	      {
	        $$invalidate(0, weeks = []);
	        $$invalidate(5, days = 7 - $hiddenDays.length);
	        set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);
	        for (let i = 0; i < $_viewDates.length / days; ++i) {
	          let dates = [];
	          for (let j = 0; j < days; ++j) {
	            dates.push($_viewDates[i * days + j]);
	          }
	          weeks.push(dates);
	        }
	      }
	    }
	  };
	  return [weeks, _viewDates, _hiddenEvents, dayMaxEvents, hiddenDays, days, $_viewDates, $dayMaxEvents, $hiddenDays];
	}
	let View$4 = class View extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$c, create_fragment$c, safe_not_equal, {});
	  }
	};
	var index$6 = {
	  createOptions(options) {
	    options.dayMaxEvents = false;
	    options.dayCellFormat = {
	      day: 'numeric'
	    };
	    options.dayPopoverFormat = {
	      month: 'long',
	      day: 'numeric',
	      year: 'numeric'
	    };
	    options.moreLinkContent = undefined;
	    // Common options
	    options.buttonText.dayGridMonth = 'month';
	    options.buttonText.close = 'Close';
	    options.theme.uniform = 'ec-uniform';
	    options.theme.dayFoot = 'ec-day-foot';
	    options.theme.popup = 'ec-popup';
	    options.view = 'dayGridMonth';
	    options.views.dayGridMonth = {
	      buttonText: btnTextMonth,
	      component: View$4,
	      dayHeaderFormat: {
	        weekday: 'short'
	      },
	      dayHeaderAriaLabelFormat: {
	        weekday: 'long'
	      },
	      displayEventEnd: false,
	      duration: {
	        months: 1
	      },
	      theme: themeView('ec-day-grid ec-month-view'),
	      titleFormat: {
	        year: 'numeric',
	        month: 'long'
	      }
	    };
	  },
	  createStores(state) {
	    state._days = days$1(state);
	    state._intlDayCell = intl(state.locale, state.dayCellFormat);
	    state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
	    state._hiddenEvents = writable({});
	    state._popupDate = writable(null);
	    state._popupChunks = writable([]);
	  }
	};

	function days(state) {
	  return derived([state.date, state.firstDay, state.hiddenDays], _ref => {
	    let [$date, $firstDay, $hiddenDays] = _ref;
	    let days = [];
	    let day = cloneDate($date);
	    let max = 7;
	    // First day of week
	    while (day.getUTCDay() !== $firstDay && max) {
	      subtractDay(day);
	      --max;
	    }
	    for (let i = 0; i < 7; ++i) {
	      if (!$hiddenDays.includes(day.getUTCDay())) {
	        days.push(cloneDate(day));
	      }
	      addDay(day);
	    }
	    return days;
	  });
	}

	/* packages/custom-grid/src/Header.svelte generated by Svelte v4.2.8 */

	function get_each_context$4$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[8] = list[i];
	  return child_ctx;
	}

	// (10:8) {#each $_days as day}
	function create_each_block$4$1(ctx) {
	  let div;
	  let span;
	  let span_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      span = element("span");
	      t = space();
	      attr(span, "aria-label", span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]));
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]));
	      attr(div, "role", "columnheader");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, span);
	      append(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, span, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8])));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$_intlDayHeaderAL, $_days*/6 && span_aria_label_value !== (span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]))) {
	        attr(span, "aria-label", span_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_days*/10) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8]));
	      if (dirty & /*$theme, $_days*/3 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function create_fragment$6$1(ctx) {
	  let div2;
	  let div0;
	  let div0_class_value;
	  let t;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let each_value = ensure_array_like( /*$_days*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4$1(get_each_context$4$1(ctx, each_value, i));
	  }
	  return {
	    c() {
	      div2 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      div1 = element("div");
	      attr(div0, "id", "daysheader");
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].days);
	      attr(div0, "role", "row");
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].hiddenScroll);
	      attr(div2, "id", "headerheader");
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[0].header);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append(div2, t);
	      append(div2, div1);
	    },
	    p(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if (dirty & /*$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader*/15) {
	        each_value = ensure_array_like( /*$_days*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$4$1(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$4$1(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(div0, null);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	      if (dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].days)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (dirty & /*$theme*/1 && div2_class_value !== (div2_class_value = /*$theme*/ctx[0].header)) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$6$1($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_days;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let {
	    theme,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    _days
	  } = getContext('state');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(2, $_intlDayHeaderAL = value));
	  component_subscribe($$self, _days, value => $$invalidate(1, $_days = value));
	  return [$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader, theme, _intlDayHeader, _intlDayHeaderAL, _days];
	}
	class Header extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$6$1, create_fragment$6$1, safe_not_equal, {});
	  }
	}

	/* packages/custom-grid/src/Body.svelte generated by Svelte v4.2.8 */

	function create_fragment$5$1(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  const default_slot_template = /*#slots*/ctx[7].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[6], null);
	  return {
	    c() {
	      div1 = element("div");
	      div0 = element("div");
	      if (default_slot) default_slot.c();
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].content);
	      attr(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')));
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      if (default_slot) {
	        default_slot.m(div0, null);
	      }

	      /*div1_binding*/
	      ctx[8](div1);
	      current = true;
	    },
	    p(ctx, _ref3) {
	      let [dirty] = _ref3;
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/64)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[6], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[6]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[6], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].content)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, $dayMaxEvents*/3 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')))) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	      }
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/
	      ctx[8](null);
	    }
	  };
	}
	function instance$5$1($$self, $$props, $$invalidate) {
	  let $theme;
	  let $dayMaxEvents;
	  let $_bodyEl;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  let {
	    dayMaxEvents,
	    _bodyEl,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(1, $dayMaxEvents = value));
	  component_subscribe($$self, _bodyEl, value => $$invalidate(2, $_bodyEl = value));
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_bodyEl = $$value;
	      _bodyEl.set($_bodyEl);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	  };
	  return [$theme, $dayMaxEvents, $_bodyEl, dayMaxEvents, _bodyEl, theme, $$scope, slots, div1_binding];
	}
	let Body$2 = class Body extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$5$1, create_fragment$5$1, safe_not_equal, {});
	  }
	};

	/* packages/custom-grid/src/Event.svelte generated by Svelte v4.2.8 */

	function create_fragment$4$2(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[8].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      }
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	    });
	  }
	  return {
	    c() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      attr(article, "class", /*classes*/ctx[4]);
	      attr(article, "style", /*style*/ctx[5]);
	      attr(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	    },
	    m(target, anchor) {
	      insert(target, article, anchor);
	      append(article, div);
	      append(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[51](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }), listen(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }), listen(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[31]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[31]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[31]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]))) /*createHandler*/ctx[31]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "pointerdown", function () {
	          if (is_function(!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8]))) (!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8])).apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/256 && switch_value !== (switch_value = /*$_interaction*/ctx[8].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[32]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[51](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$4$2($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_hiddenEvents;
	  let $dayMaxEvents;
	  let $_popupDate;
	  let $_interaction;
	  let $_view;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let {
	    chunk
	  } = $$props;
	  let {
	    longChunks = {}
	  } = $$props;
	  let {
	    inPopup = false
	  } = $$props;
	  let {
	    dayMaxEvents,
	    displayEventEnd,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _hiddenEvents,
	    _popupDate
	  } = getContext('state');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(54, $dayMaxEvents = value));
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(43, $displayEventEnd = value));
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(49, $eventBackgroundColor = value));
	  component_subscribe($$self, eventTextColor, value => $$invalidate(46, $eventTextColor = value));
	  component_subscribe($$self, eventClick, value => $$invalidate(39, $eventClick = value));
	  component_subscribe($$self, eventColor, value => $$invalidate(48, $eventColor = value));
	  component_subscribe($$self, eventContent, value => $$invalidate(42, $eventContent = value));
	  component_subscribe($$self, eventClassNames, value => $$invalidate(44, $eventClassNames = value));
	  component_subscribe($$self, eventDidMount, value => $$invalidate(56, $eventDidMount = value));
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  component_subscribe($$self, _view, value => $$invalidate(40, $_view = value));
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(41, $_intlEventTime = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  component_subscribe($$self, _iClasses, value => $$invalidate(45, $_iClasses = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(50, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(47, $_resTxtColor = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(53, $_hiddenEvents = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(55, $_popupDate = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let margin = 1;
	  let hidden = false;
	  let display;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => $_interaction.action.drag(event, jsEvent, resize, inPopup ? $_popupDate : undefined) : undefined;
	  }
	  function reposition() {
	    if (!el || previewEvent(display) || inPopup) {
	      return;
	    }
	    $$invalidate(37, margin = repositionEvent(chunk, longChunks, height(el)));
	    if ($dayMaxEvents === true) {
	      hide();
	    } else {
	      $$invalidate(38, hidden = false);
	    }
	  }
	  function hide() {
	    let dayEl = ancestor(el, 2);
	    let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
	    $$invalidate(38, hidden = chunk.bottom > h);
	    let update = false;

	    // Hide or show the event throughout all days
	    for (let date of chunk.dates) {
	      let hiddenEvents = $_hiddenEvents[date.getTime()];
	      if (hiddenEvents) {
	        let size = hiddenEvents.size;
	        if (hidden) {
	          hiddenEvents.add(chunk.event);
	        } else {
	          hiddenEvents.delete(chunk.event);
	        }
	        if (size !== hiddenEvents.size) {
	          update = true;
	        }
	      }
	    }
	    if (update) {
	      _hiddenEvents.set($_hiddenEvents);
	    }
	  }
	  function footHeight(dayEl) {
	    let h = 0;
	    for (let i = 0; i < chunk.days; ++i) {
	      h = max(h, height(dayEl.lastElementChild));
	      dayEl = dayEl.nextElementSibling;
	      if (!dayEl) {
	        break;
	      }
	    }
	    return h;
	  }
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(33, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(34, longChunks = $$props.longChunks);
	    if ('inPopup' in $$props) $$invalidate(35, inPopup = $$props.inPopup);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/4) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme*/37 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, chunk, margin, hidden, $_iClasses, $eventClassNames, $_view*/1041092) {
	      {
	        $$invalidate(1, display = event.display);

	        // Class & Style
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        if (hidden) {
	          $$invalidate(5, style += 'visibility:hidden;');
	        }
	        $$invalidate(4, classes = [$theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/7684) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/256) {
	      // Onclick handler
	      $$invalidate(7, onclick = createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $_interaction, $eventMouseEnter, $eventMouseLeave, dayMaxEvents, displayEventEnd, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _hiddenEvents, _popupDate, createHandler, createDragHandler, chunk, longChunks, inPopup, reposition, margin, hidden, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	let Event$3 = class Event extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$4$2, create_fragment$4$2, safe_not_equal, {
	      chunk: 33,
	      longChunks: 34,
	      inPopup: 35,
	      reposition: 36
	    }, null, [-1, -1]);
	  }
	  get reposition() {
	    return this.$$.ctx[36];
	  }
	};

	/* packages/custom-grid/src/Popup.svelte generated by Svelte v4.2.8 */

	function get_each_context$3$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	// (100:8) {#each $_popupChunks as chunk (chunk.event)}
	function create_each_block$3$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*chunk*/ctx[20],
	      inPopup: true
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty & /*$_popupChunks*/1) event_changes.chunk = /*chunk*/ctx[20];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	}
	function create_fragment$3$3(ctx) {
	  let div2;
	  let div0;
	  let time;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let a;
	  let t1;
	  let a_aria_label_value;
	  let div0_class_value;
	  let t2;
	  let div1;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like( /*$_popupChunks*/ctx[0]);
	  const get_key = ctx => /*chunk*/ctx[20].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$3$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$3$1(key, child_ctx));
	  }
	  return {
	    c() {
	      div2 = element("div");
	      div0 = element("div");
	      time = element("time");
	      t0 = space();
	      a = element("a");
	      t1 = text("×");
	      t2 = space();
	      div1 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(time, "datetime", time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10));
	      attr(a, "role", "button");
	      attr(a, "tabindex", "0");
	      attr(a, "aria-label", a_aria_label_value = /*$buttonText*/ctx[6].close);
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[4].dayHead);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[4].events);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[4].popup);
	      attr(div2, "style", /*style*/ctx[2]);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      append(div0, time);
	      append(div0, t0);
	      append(div0, a);
	      append(a, t1);
	      append(div2, t2);
	      append(div2, div1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }

	      /*div2_binding*/
	      ctx[16](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]))), listen(a, "click", stop_propagation( /*close*/ctx[13])), listen(a, "keydown", keyEnter( /*close*/ctx[13])), action_destroyer(outsideEvent.call(null, div2, 'pointerdown')), listen(div2, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[15])), listen(div2, "pointerdownoutside", /*handlePointerDownOutside*/ctx[14])];
	        mounted = true;
	      }
	    },
	    p(ctx, _ref4) {
	      let [dirty] = _ref4;
	      if (!current || dirty & /*$_popupDate*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayPopover, $_popupDate*/40) setContent_action.update.call(null, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]));
	      if (!current || dirty & /*$buttonText*/64 && a_aria_label_value !== (a_aria_label_value = /*$buttonText*/ctx[6].close)) {
	        attr(a, "aria-label", a_aria_label_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div0_class_value !== (div0_class_value = /*$theme*/ctx[4].dayHead)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$_popupChunks*/1) {
	        each_value = ensure_array_like( /*$_popupChunks*/ctx[0]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$3$1, null, get_each_context$3$1);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/16 && div1_class_value !== (div1_class_value = /*$theme*/ctx[4].events)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div2_class_value !== (div2_class_value = /*$theme*/ctx[4].popup)) {
	        attr(div2, "class", div2_class_value);
	      }
	      if (!current || dirty & /*style*/4) {
	        attr(div2, "style", /*style*/ctx[2]);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div2_binding*/
	      ctx[16](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$3$3($$self, $$props, $$invalidate) {
	  let $_interaction;
	  let $_popupDate;
	  let $_popupChunks;
	  let $theme;
	  let $_intlDayPopover;
	  let $buttonText;
	  let {
	    buttonText,
	    theme,
	    _interaction,
	    _intlDayPopover,
	    _popupDate,
	    _popupChunks
	  } = getContext('state');
	  component_subscribe($$self, buttonText, value => $$invalidate(6, $buttonText = value));
	  component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(17, $_interaction = value));
	  component_subscribe($$self, _intlDayPopover, value => $$invalidate(5, $_intlDayPopover = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(3, $_popupDate = value));
	  component_subscribe($$self, _popupChunks, value => $$invalidate(0, $_popupChunks = value));
	  let el;
	  let style = '';
	  function position() {
	    let dayEl = ancestor(el, 1);
	    let bodyEl = ancestor(dayEl, 3);
	    let popupRect = rect(el);
	    let dayRect = rect(dayEl);
	    let bodyRect = rect(bodyEl);
	    $$invalidate(2, style = '');
	    let left;
	    if (popupRect.width >= bodyRect.width) {
	      left = bodyRect.left - dayRect.left;
	      let right = dayRect.right - bodyRect.right;
	      $$invalidate(2, style += `right:${right}px;`);
	    } else {
	      left = (dayRect.width - popupRect.width) / 2;
	      if (dayRect.left + left < bodyRect.left) {
	        left = bodyRect.left - dayRect.left;
	      } else if (dayRect.left + left + popupRect.width > bodyRect.right) {
	        left = bodyRect.right - dayRect.left - popupRect.width;
	      }
	    }
	    $$invalidate(2, style += `left:${left}px;`);
	    let top;
	    if (popupRect.height >= bodyRect.height) {
	      top = bodyRect.top - dayRect.top;
	      let bottom = dayRect.bottom - bodyRect.bottom;
	      $$invalidate(2, style += `bottom:${bottom}px;`);
	    } else {
	      top = (dayRect.height - popupRect.height) / 2;
	      if (dayRect.top + top < bodyRect.top) {
	        top = bodyRect.top - dayRect.top;
	      } else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
	        top = bodyRect.bottom - dayRect.top - popupRect.height;
	      }
	    }
	    $$invalidate(2, style += `top:${top}px;`);
	  }
	  function reposition() {
	    // Skip the first call (el is not defined at this time)
	    if (el) {
	      $$invalidate(2, style = '');

	      // Let chunks to update/mount then position the popup
	      tick().then(() => {
	        if ($_popupChunks.length) {
	          position();
	        } else {
	          close();
	        }
	      });
	    }
	  }
	  function close(e) {
	    set_store_value(_popupDate, $_popupDate = null, $_popupDate);
	  }
	  function handlePointerDownOutside(e) {
	    close();
	    $_interaction.action?.noClick();
	  }
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_popupChunks*/1) {
	      if ($_popupChunks) {
	        // Fire reposition only on popup chunks change
	        reposition();
	      }
	    }
	  };
	  return [$_popupChunks, el, style, $_popupDate, $theme, $_intlDayPopover, $buttonText, buttonText, theme, _interaction, _intlDayPopover, _popupDate, _popupChunks, close, handlePointerDownOutside, pointerdown_handler, div2_binding];
	}
	class Popup extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3$3, create_fragment$3$3, safe_not_equal, {});
	  }
	}

	/* packages/custom-grid/src/Day.svelte generated by Svelte v4.2.8 */

	function get_each_context$2$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[43] = list[i];
	  child_ctx[44] = list;
	  child_ctx[45] = i;
	  return child_ctx;
	}

	// (120:4) {#if iChunks[1] && datesEqual(iChunks[1].date, date)}
	function create_if_block_3$1(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*iChunks*/ctx[2][1]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[12].events);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][1];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = /*$theme*/ctx[12].events)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(event);
	    }
	  };
	}

	// (126:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
	function create_if_block_2$2(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*iChunks*/ctx[2][0]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview));
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][0];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(event);
	    }
	  };
	}

	// (132:8) {#each dayChunks as chunk, i (chunk.event)}
	function create_each_block$2$1(key_1, ctx) {
	  let first;
	  let event;
	  let i = /*i*/ctx[45];
	  let current;
	  const assign_event = () => /*event_binding*/ctx[36](event, i);
	  const unassign_event = () => /*event_binding*/ctx[36](null, i);
	  let event_props = {
	    chunk: /*chunk*/ctx[43],
	    longChunks: /*longChunks*/ctx[1]
	  };
	  event = new Event$3({
	    props: event_props
	  });
	  assign_event();
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (i !== /*i*/ctx[45]) {
	        unassign_event();
	        i = /*i*/ctx[45];
	        assign_event();
	      }
	      const event_changes = {};
	      if (dirty[0] & /*dayChunks*/16) event_changes.chunk = /*chunk*/ctx[43];
	      if (dirty[0] & /*longChunks*/2) event_changes.longChunks = /*longChunks*/ctx[1];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      unassign_event();
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (136:4) {#if showPopup}
	function create_if_block_1$2(ctx) {
	  let popup;
	  let current;
	  popup = new Popup({});
	  return {
	    c() {
	      create_component(popup.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(popup, target, anchor);
	      current = true;
	    },
	    i(local) {
	      if (current) return;
	      transition_in(popup.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(popup.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(popup, detaching);
	    }
	  };
	}

	// (140:8) {#if hiddenEvents.size}
	function create_if_block$5(ctx) {
	  let a;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      a = element("a");
	      attr(a, "role", "button");
	      attr(a, "tabindex", "0");
	      attr(a, "aria-haspopup", "true");
	    },
	    m(target, anchor) {
	      insert(target, a, anchor);
	      if (!mounted) {
	        dispose = [listen(a, "click", stop_propagation( /*showMore*/ctx[26])), listen(a, "keydown", keyEnter( /*showMore*/ctx[26])), listen(a, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[35])), action_destroyer(setContent_action = setContent.call(null, a, /*moreLink*/ctx[6]))];
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/64) setContent_action.update.call(null, /*moreLink*/ctx[6]);
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(a);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function create_fragment$2$3(ctx) {
	  let div2;
	  let time;
	  let time_class_value;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	  let t1;
	  let show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	  let t2;
	  let div0;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div0_class_value;
	  let t3;
	  let t4;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let if_block0 = show_if_1 && create_if_block_3$1(ctx);
	  let if_block1 = show_if && create_if_block_2$2(ctx);
	  let each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	  const get_key = ctx => /*chunk*/ctx[43].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$2$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$2$1(key, child_ctx));
	  }
	  let if_block2 = /*showPopup*/ctx[7] && create_if_block_1$2();
	  let if_block3 = /*hiddenEvents*/ctx[5].size && create_if_block$5(ctx);
	  return {
	    c() {
	      div2 = element("div");
	      time = element("time");
	      t0 = space();
	      if (if_block0) if_block0.c();
	      t1 = space();
	      if (if_block1) if_block1.c();
	      t2 = space();
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();
	      div1 = element("div");
	      if (if_block3) if_block3.c();
	      attr(time, "class", time_class_value = /*$theme*/ctx[12].dayHead);
	      attr(time, "datetime", time_datetime_value = toISOString( /*date*/ctx[0], 10));
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[12].events);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[12].dayFoot);
	      attr(div2, "class", div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[8] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[9] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[10] ? ' ' + /*$theme*/ctx[12].highlight : '')));
	      attr(div2, "role", "cell");
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, time);
	      append(div2, t0);
	      if (if_block0) if_block0.m(div2, null);
	      append(div2, t1);
	      if (if_block1) if_block1.m(div2, null);
	      append(div2, t2);
	      append(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append(div2, t3);
	      if (if_block2) if_block2.m(div2, null);
	      append(div2, t4);
	      append(div2, div1);
	      if (if_block3) if_block3.m(div1, null);
	      /*div2_binding*/
	      ctx[37](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [listen(window, "resize", /*reposition*/ctx[27]), action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]))), listen(div2, "pointerenter", function () {
	          if (is_function( /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]))) /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]).apply(this, arguments);
	        }), listen(div2, "pointerleave", function () {
	          if (is_function( /*$_interaction*/ctx[13].pointer?.leave)) /*$_interaction*/ctx[13].pointer?.leave.apply(this, arguments);
	        }), listen(div2, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[13].action?.select)) /*$_interaction*/ctx[13].action?.select.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4096 && time_class_value !== (time_class_value = /*$theme*/ctx[12].dayHead)) {
	        attr(time, "class", time_class_value);
	      }
	      if (!current || dirty[0] & /*date*/1 && time_datetime_value !== (time_datetime_value = toISOString( /*date*/ctx[0], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayCell, date*/16385) setContent_action.update.call(null, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]));
	      if (dirty[0] & /*iChunks, date*/5) show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	      if (show_if_1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_3$1(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div2, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, () => {
	          if_block0 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*iChunks, date*/5) show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	      if (show_if) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_2$2(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div2, t2);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*dayChunks, longChunks, refs*/2066) {
	        each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2$1, null, get_each_context$2$1);
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div0_class_value !== (div0_class_value = /*$theme*/ctx[12].events)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if ( /*showPopup*/ctx[7]) {
	        if (if_block2) {
	          if (dirty[0] & /*showPopup*/128) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_1$2();
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div2, t4);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, () => {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	      if ( /*hiddenEvents*/ctx[5].size) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block$5(ctx);
	          if_block3.c();
	          if_block3.m(div1, null);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div1_class_value !== (div1_class_value = /*$theme*/ctx[12].dayFoot)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty[0] & /*$theme, date, isToday, otherMonth, highlight*/5889 && div2_class_value !== (div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[8] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[9] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[10] ? ' ' + /*$theme*/ctx[12].highlight : '')))) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      transition_in(if_block2);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      transition_out(if_block2);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      /*div2_binding*/
	      ctx[37](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$2$4($$self, $$props, $$invalidate) {
	  let $_hiddenEvents;
	  let $_popupChunks;
	  let $_popupDate;
	  let $moreLinkContent;
	  let $highlightedDates;
	  let $currentDate;
	  let $_today;
	  let $theme;
	  let $_interaction;
	  let $_intlDayCell;
	  let {
	    date
	  } = $$props;
	  let {
	    chunks
	  } = $$props;
	  let {
	    longChunks
	  } = $$props;
	  let {
	    iChunks = []
	  } = $$props;
	  let {
	    date: currentDate,
	    dayMaxEvents,
	    highlightedDates,
	    moreLinkContent,
	    theme,
	    _hiddenEvents,
	    _intlDayCell,
	    _popupDate,
	    _popupChunks,
	    _today,
	    _interaction,
	    _queue
	  } = getContext('state');
	  component_subscribe($$self, currentDate, value => $$invalidate(33, $currentDate = value));
	  component_subscribe($$self, highlightedDates, value => $$invalidate(32, $highlightedDates = value));
	  component_subscribe($$self, moreLinkContent, value => $$invalidate(31, $moreLinkContent = value));
	  component_subscribe($$self, theme, value => $$invalidate(12, $theme = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(29, $_hiddenEvents = value));
	  component_subscribe($$self, _intlDayCell, value => $$invalidate(14, $_intlDayCell = value));
	  component_subscribe($$self, _popupDate, value => $$invalidate(30, $_popupDate = value));
	  component_subscribe($$self, _popupChunks, value => $$invalidate(38, $_popupChunks = value));
	  component_subscribe($$self, _today, value => $$invalidate(34, $_today = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(13, $_interaction = value));
	  let el;
	  let dayChunks;
	  let isToday;
	  let otherMonth;
	  let highlight;
	  let hiddenEvents = new Set(); // hidden events of this day
	  let moreLink = '';
	  let showPopup;
	  let refs = [];
	  function createPointerEnterHandler(interaction) {
	    return interaction.pointer ? jsEvent => interaction.pointer.enterCustomGrid(date, jsEvent) : undefined;
	  }
	  function showMore() {
	    set_store_value(_popupDate, $_popupDate = date, $_popupDate);
	  }
	  function setPopupChunks() {
	    let nextDay = addDay(cloneDate(date));
	    let chunks = dayChunks.concat(longChunks[date.getTime()]?.chunks || []);
	    set_store_value(_popupChunks, $_popupChunks = chunks.map(chunk => assign({}, chunk, createEventChunk(chunk.event, date, nextDay), {
	      days: 1,
	      dates: [date]
	    })).sort((a, b) => a.top - b.top), $_popupChunks);
	  }
	  function reposition() {
	    $$invalidate(11, refs.length = dayChunks.length, refs);
	    for (let ref of refs) {
	      ref?.reposition?.();
	    }
	  }
	  afterUpdate(reposition);
	  let debounceHandle = {};
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function event_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(11, refs);
	    });
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(28, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*hiddenEvents, chunks, date, dayChunks*/268435505) {
	      {
	        $$invalidate(4, dayChunks = []);
	        hiddenEvents.clear();
	        (($$invalidate(5, hiddenEvents), $$invalidate(28, chunks)), $$invalidate(0, date)), $$invalidate(4, dayChunks);
	        for (let chunk of chunks) {
	          if (datesEqual(chunk.date, date)) {
	            dayChunks.push(chunk);
	          } // if ($dayMaxEvents !== false && dayChunks.length > $dayMaxEvents) {
	          //chunk.hidden = true;
	        } // }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*date, hiddenEvents*/33) {
	      set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$_today*/8) {
	      $$invalidate(8, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/6) {
	      {
	        $$invalidate(9, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
	        $$invalidate(10, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_hiddenEvents, hiddenEvents, moreLink*/536871008 | $$self.$$.dirty[1] & /*$moreLinkContent*/1) {
	      if ($_hiddenEvents && hiddenEvents.size) {
	        // make Svelte update this block on $_hiddenEvents update
	        let text = '+' + hiddenEvents.size + ' more';
	        if ($moreLinkContent) {
	          $$invalidate(6, moreLink = is_function($moreLinkContent) ? $moreLinkContent({
	            num: hiddenEvents.size,
	            text
	          }) : $moreLinkContent);
	          if (typeof moreLink === 'string') {
	            $$invalidate(6, moreLink = {
	              html: moreLink
	            });
	          }
	        } else {
	          $$invalidate(6, moreLink = {
	            html: text
	          });
	        }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_popupDate, date*/1073741825) {
	      $$invalidate(7, showPopup = $_popupDate && datesEqual(date, $_popupDate));
	    }
	    if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/146) {
	      if (showPopup && longChunks && dayChunks) {
	        // Let chunks to reposition then set popup chunks
	        tick().then(setPopupChunks);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*el, date*/9) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource: undefined,
	          dayEl: el
	        }));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_hiddenEvents*/536870912) {
	      if ($_hiddenEvents) {
	        debounce(reposition, debounceHandle, _queue);
	      }
	    }
	  };
	  return [date, longChunks, iChunks, el, dayChunks, hiddenEvents, moreLink, showPopup, isToday, otherMonth, highlight, refs, $theme, $_interaction, $_intlDayCell, currentDate, highlightedDates, moreLinkContent, theme, _hiddenEvents, _intlDayCell, _popupDate, _popupChunks, _today, _interaction, createPointerEnterHandler, showMore, reposition, chunks, $_hiddenEvents, $_popupDate, $moreLinkContent, $highlightedDates, $currentDate, $_today, pointerdown_handler, event_binding, div2_binding];
	}
	let Day$3 = class Day extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$4, create_fragment$2$3, safe_not_equal, {
	      date: 0,
	      chunks: 28,
	      longChunks: 1,
	      iChunks: 2
	    }, null, [-1, -1]);
	  }
	};

	/* packages/custom-grid/src/Week.svelte generated by Svelte v4.2.8 */

	function get_each_context$1$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[14] = list[i];
	  return child_ctx;
	}

	// (44:4) {#each dates as date}
	function create_each_block$1$2(ctx) {
	  let day;
	  let current;
	  day = new Day$3({
	    props: {
	      date: /*date*/ctx[14],
	      chunks: /*chunks*/ctx[1],
	      longChunks: /*longChunks*/ctx[2],
	      iChunks: /*iChunks*/ctx[3]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*dates*/1) day_changes.date = /*date*/ctx[14];
	      if (dirty & /*chunks*/2) day_changes.chunks = /*chunks*/ctx[1];
	      if (dirty & /*longChunks*/4) day_changes.longChunks = /*longChunks*/ctx[2];
	      if (dirty & /*iChunks*/8) day_changes.iChunks = /*iChunks*/ctx[3];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}
	function create_fragment$1$4(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let each_value = ensure_array_like( /*dates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1$2(get_each_context$1$2(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(div, "class", div_class_value = /*$theme*/ctx[4].days);
	      attr(div, "role", "row");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	    },
	    p(ctx, _ref5) {
	      let [dirty] = _ref5;
	      if (dirty & /*dates, chunks, longChunks, iChunks*/15) {
	        each_value = ensure_array_like( /*dates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1$2(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1$2(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/16 && div_class_value !== (div_class_value = /*$theme*/ctx[4].days)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$1$4($$self, $$props, $$invalidate) {
	  let $hiddenDays;
	  let $_iEvents;
	  let $_events;
	  let $theme;
	  let {
	    dates
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    hiddenDays,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(13, $_events = value));
	  component_subscribe($$self, _iEvents, value => $$invalidate(12, $_iEvents = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(11, $hiddenDays = value));
	  component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	  let chunks,
	    longChunks,
	    iChunks = [];
	  let start;
	  let end;
	  $$self.$$set = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*dates*/1) {
	      {
	        $$invalidate(9, start = dates[0]);
	        $$invalidate(10, end = addDay(cloneDate(dates[dates.length - 1])));
	      }
	    }
	    if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/11778) {
	      {
	        $$invalidate(1, chunks = []);
	        for (let event of $_events) {
	          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        $$invalidate(2, longChunks = prepareEventChunks(chunks, $hiddenDays));
	      }
	    }
	    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/7680) {
	      $$invalidate(3, iChunks = $_iEvents.map(event => {
	        let chunk;
	        if (event && eventIntersects(event, start, end)) {
	          chunk = createEventChunk(event, start, end);
	          prepareEventChunks([chunk], $hiddenDays);
	        } else {
	          chunk = null;
	        }
	        return chunk;
	      }));
	    }
	  };
	  return [dates, chunks, longChunks, iChunks, $theme, _events, _iEvents, hiddenDays, theme, start, end, $hiddenDays, $_iEvents, $_events];
	}
	let Week$1 = class Week extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$4, create_fragment$1$4, safe_not_equal, {
	      dates: 0
	    });
	  }
	};

	/* packages/custom-grid/src/View.svelte generated by Svelte v4.2.8 */

	function get_each_context$8(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[12] = list[i];
	  return child_ctx;
	}

	// (36:0) {#each weeks as dates}
	function create_each_block$8(ctx) {
	  let week;
	  let current;
	  week = new Week$1({
	    props: {
	      dates: /*dates*/ctx[12]
	    }
	  });
	  return {
	    c() {
	      create_component(week.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const week_changes = {};
	      if (dirty & /*weeks*/1) week_changes.dates = /*dates*/ctx[12];
	      week.$set(week_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	}

	// (34:0) <Body>
	function create_default_slot$4(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let each_value = ensure_array_like( /*weeks*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(div, "class", div_class_value = /*$theme*/ctx[1].days);
	      attr(div, "role", "row");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*weeks*/1) {
	        each_value = ensure_array_like( /*weeks*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$8(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$8(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].days)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$b(ctx) {
	  let t0;
	  let header;
	  let t1;
	  let body;
	  let current;
	  header = new Header({});
	  body = new Body$2({
	    props: {
	      $$slots: {
	        default: [create_default_slot$4]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      t0 = text("y\n");
	      create_component(header.$$.fragment);
	      t1 = space();
	      create_component(body.$$.fragment);
	    },
	    m(target, anchor) {
	      insert(target, t0, anchor);
	      mount_component(header, target, anchor);
	      insert(target, t1, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p(ctx, _ref6) {
	      let [dirty] = _ref6;
	      const body_changes = {};
	      if (dirty & /*$$scope, $theme, weeks*/32771) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(header.$$.fragment, local);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(header.$$.fragment, local);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(t0);
	        detach(t1);
	      }
	      destroy_component(header, detaching);
	      destroy_component(body, detaching);
	    }
	  };
	}
	function instance$b($$self, $$props, $$invalidate) {
	  let $_viewDates;
	  let $dayMaxEvents;
	  let $_hiddenEvents;
	  let $hiddenDays;
	  let $theme;
	  let {
	    _viewDates,
	    _hiddenEvents,
	    dayMaxEvents,
	    hiddenDays,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _viewDates, value => $$invalidate(8, $_viewDates = value));
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(11, $_hiddenEvents = value));
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(9, $dayMaxEvents = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(10, $hiddenDays = value));
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  let weeks;
	  let days;
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_viewDates, $hiddenDays, $dayMaxEvents, days, weeks*/1921) {
	      {
	        $$invalidate(0, weeks = []);
	        $$invalidate(7, days = $_viewDates.length - $hiddenDays.length);
	        set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);
	        for (let i = 0; i < $_viewDates.length / days; ++i) {
	          let dates = [];
	          for (let j = 0; j < days; ++j) {
	            dates.push($_viewDates[i * days + j]);
	          }
	          console.log('dates:', dates);
	        }
	        weeks.push(dates);
	        console.log('days:', days);
	        console.log('week:', $_viewDates);
	      }
	    }
	  };
	  return [weeks, $theme, _viewDates, _hiddenEvents, dayMaxEvents, hiddenDays, theme, days, $_viewDates, $dayMaxEvents, $hiddenDays];
	}
	let View$3 = class View extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$b, create_fragment$b, safe_not_equal, {});
	  }
	};
	var index$5 = {
	  createOptions(options) {
	    options.dayMaxEvents = false;
	    options.dayCellFormat = {
	      day: 'numeric'
	    };
	    options.dayPopoverFormat = {
	      month: 'long',
	      day: 'numeric',
	      year: 'numeric'
	    };
	    options.moreLinkContent = undefined;
	    // Common options
	    options.buttonText.customGridMonth = 'custom';
	    options.buttonText.close = 'Close';
	    options.theme.uniform = 'ec-uniform';
	    options.theme.dayFoot = 'ec-day-foot';
	    options.theme.popup = 'ec-popup';
	    options.view = 'customGridMonth';
	    options.views.customGridMonth = {
	      buttonText: btnTextMonth,
	      component: View$3,
	      dayHeaderFormat: {
	        weekday: 'short'
	      },
	      dayHeaderAriaLabelFormat: {
	        weekday: 'long'
	      },
	      displayEventEnd: false,
	      duration: {
	        months: 1
	      },
	      theme: themeView('ec-custom-grid ec-month-view'),
	      titleFormat: {
	        year: 'numeric',
	        month: 'long'
	      }
	    };
	  },
	  createStores(state) {
	    state._days = days(state);
	    state._intlDayCell = intl(state.locale, state.dayCellFormat);
	    state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
	    state._hiddenEvents = writable({});
	    state._popupDate = writable(null);
	    state._popupChunks = writable([]);
	  }
	};

	/* packages/list/src/Body.svelte generated by Svelte v4.2.8 */

	function create_fragment$3$2(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  const default_slot_template = /*#slots*/ctx[5].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[4], null);
	  return {
	    c() {
	      div1 = element("div");
	      div0 = element("div");
	      if (default_slot) default_slot.c();
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].content);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].body);
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      if (default_slot) {
	        default_slot.m(div0, null);
	      }

	      /*div1_binding*/
	      ctx[6](div1);
	      current = true;
	    },
	    p(ctx, _ref) {
	      let [dirty] = _ref;
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/16)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[4], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[4]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[4], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].content)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].body)) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	      }
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/
	      ctx[6](null);
	    }
	  };
	}
	function instance$3$2($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_bodyEl;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  let {
	    _bodyEl,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(1, $_bodyEl = value));
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_bodyEl = $$value;
	      _bodyEl.set($_bodyEl);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	  };
	  return [$theme, $_bodyEl, _bodyEl, theme, $$scope, slots, div1_binding];
	}
	let Body$1 = class Body extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3$2, create_fragment$3$2, safe_not_equal, {});
	  }
	};

	/* packages/list/src/Event.svelte generated by Svelte v4.2.8 */

	function create_fragment$2$2(ctx) {
	  let article;
	  let div0;
	  let div0_class_value;
	  let t;
	  let div1;
	  let div1_class_value;
	  let setContent_action;
	  let article_role_value;
	  let article_tabindex_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      article = element("article");
	      div0 = element("div");
	      t = space();
	      div1 = element("div");
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].eventTag);
	      attr(div0, "style", /*style*/ctx[3]);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].eventBody);
	      attr(article, "class", /*classes*/ctx[2]);
	      attr(article, "role", article_role_value = /*onclick*/ctx[5] ? 'button' : undefined);
	      attr(article, "tabindex", article_tabindex_value = /*onclick*/ctx[5] ? 0 : undefined);
	    },
	    m(target, anchor) {
	      insert(target, article, anchor);
	      append(article, div0);
	      append(article, t);
	      append(article, div1);
	      /*article_binding*/
	      ctx[39](article);
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div1, /*content*/ctx[4])), listen(article, "click", function () {
	          if (is_function( /*onclick*/ctx[5])) /*onclick*/ctx[5].apply(this, arguments);
	        }), listen(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[5] && keyEnter( /*onclick*/ctx[5]))) ( /*onclick*/ctx[5] && keyEnter( /*onclick*/ctx[5])).apply(this, arguments);
	        }), listen(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[25]( /*$eventMouseEnter*/ctx[6]))) /*createHandler*/ctx[25]( /*$eventMouseEnter*/ctx[6]).apply(this, arguments);
	        }), listen(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[25]( /*$eventMouseLeave*/ctx[7]))) /*createHandler*/ctx[25]( /*$eventMouseLeave*/ctx[7]).apply(this, arguments);
	        }), listen(article, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[8].action?.noAction)) /*$_interaction*/ctx[8].action?.noAction.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].eventTag)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (dirty[0] & /*style*/8) {
	        attr(div0, "style", /*style*/ctx[3]);
	      }
	      if (dirty[0] & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].eventBody)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/16) setContent_action.update.call(null, /*content*/ctx[4]);
	      if (dirty[0] & /*classes*/4) {
	        attr(article, "class", /*classes*/ctx[2]);
	      }
	      if (dirty[0] & /*onclick*/32 && article_role_value !== (article_role_value = /*onclick*/ctx[5] ? 'button' : undefined)) {
	        attr(article, "role", article_role_value);
	      }
	      if (dirty[0] & /*onclick*/32 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[5] ? 0 : undefined)) {
	        attr(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(article);
	      }

	      /*article_binding*/
	      ctx[39](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$2$3($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    chunk
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventClick,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _resBgColor,
	    _resTxtColor,
	    _interaction
	  } = getContext('state');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(32, $displayEventEnd = value));
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(37, $eventBackgroundColor = value));
	  component_subscribe($$self, eventTextColor, value => $$invalidate(34, $eventTextColor = value));
	  component_subscribe($$self, eventColor, value => $$invalidate(36, $eventColor = value));
	  component_subscribe($$self, eventContent, value => $$invalidate(31, $eventContent = value));
	  component_subscribe($$self, eventClassNames, value => $$invalidate(33, $eventClassNames = value));
	  component_subscribe($$self, eventClick, value => $$invalidate(28, $eventClick = value));
	  component_subscribe($$self, eventDidMount, value => $$invalidate(41, $eventDidMount = value));
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(6, $eventMouseEnter = value));
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(7, $eventMouseLeave = value));
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  component_subscribe($$self, _view, value => $$invalidate(29, $_view = value));
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(30, $_intlEventTime = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(38, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(35, $_resTxtColor = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  function createHandler(fn) {
	    return jsEvent => {
	      if (is_function(fn)) {
	        fn({
	          event: toEventWithLocalDates(event),
	          el,
	          jsEvent,
	          view: toViewWithLocalDates($_view)
	        });
	      }
	    };
	  }
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(26, chunk = $$props.chunk);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*chunk*/67108864) {
	      $$invalidate(27, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme, $_view*/671088649 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, $eventClassNames*/252) {
	      {
	        // Class & Style
	        $$invalidate(3, style = '');
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        if (bgColor) {
	          $$invalidate(3, style = `background-color:${bgColor};`);
	        }
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        if (txtColor) {
	          $$invalidate(3, style += `color:${txtColor};`);
	        }
	        $$invalidate(2, classes = [$theme.event, ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*chunk, $theme, $_intlEventTime, $_view*/1677721601 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent*/3) {
	      {
	        // Content
	        $$invalidate(4, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$eventClick*/268435456) {
	      // Onclick handler
	      $$invalidate(5, onclick = createHandler($eventClick));
	    }
	  };
	  return [$theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventBackgroundColor, eventTextColor, eventColor, eventContent, eventClassNames, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _resBgColor, _resTxtColor, _interaction, createHandler, chunk, event, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	let Event$2 = class Event extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$3, create_fragment$2$2, safe_not_equal, {
	      chunk: 26
	    }, null, [-1, -1]);
	  }
	};

	/* packages/list/src/Day.svelte generated by Svelte v4.2.8 */

	function get_each_context$1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  return child_ctx;
	}

	// (49:0) {#if chunks.length}
	function create_if_block$1$2(ctx) {
	  let div;
	  let h4;
	  let time0;
	  let setContent_action;
	  let t0;
	  let time1;
	  let time1_class_value;
	  let setContent_action_1;
	  let h4_class_value;
	  let t1;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like( /*chunks*/ctx[2]);
	  const get_key = ctx => /*chunk*/ctx[21].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$1$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$1$1(key, child_ctx));
	  }
	  return {
	    c() {
	      div = element("div");
	      h4 = element("h4");
	      time0 = element("time");
	      t0 = space();
	      time1 = element("time");
	      t1 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(time0, "datetime", /*datetime*/ctx[5]);
	      attr(time1, "class", time1_class_value = /*$theme*/ctx[6].daySide);
	      attr(time1, "datetime", /*datetime*/ctx[5]);
	      attr(h4, "class", h4_class_value = /*$theme*/ctx[6].dayHead);
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[6].day + " " + /*$theme*/ctx[6].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[3] ? ' ' + /*$theme*/ctx[6].today : '') + ( /*highlight*/ctx[4] ? ' ' + /*$theme*/ctx[6].highlight : '')));
	      attr(div, "role", "listitem");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, h4);
	      append(h4, time0);
	      append(h4, t0);
	      append(h4, time1);
	      append(div, t1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }

	      /*div_binding*/
	      ctx[20](div);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time0, /*$_intlListDay*/ctx[8].format( /*date*/ctx[0]))), action_destroyer(setContent_action_1 = setContent.call(null, time1, /*$_intlListDaySide*/ctx[9].format( /*date*/ctx[0]))), listen(div, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[7].action?.select)) /*$_interaction*/ctx[7].action?.select.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty & /*datetime*/32) {
	        attr(time0, "datetime", /*datetime*/ctx[5]);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlListDay, date*/257) setContent_action.update.call(null, /*$_intlListDay*/ctx[8].format( /*date*/ctx[0]));
	      if (!current || dirty & /*$theme*/64 && time1_class_value !== (time1_class_value = /*$theme*/ctx[6].daySide)) {
	        attr(time1, "class", time1_class_value);
	      }
	      if (!current || dirty & /*datetime*/32) {
	        attr(time1, "datetime", /*datetime*/ctx[5]);
	      }
	      if (setContent_action_1 && is_function(setContent_action_1.update) && dirty & /*$_intlListDaySide, date*/513) setContent_action_1.update.call(null, /*$_intlListDaySide*/ctx[9].format( /*date*/ctx[0]));
	      if (!current || dirty & /*$theme*/64 && h4_class_value !== (h4_class_value = /*$theme*/ctx[6].dayHead)) {
	        attr(h4, "class", h4_class_value);
	      }
	      if (dirty & /*chunks*/4) {
	        each_value = ensure_array_like( /*chunks*/ctx[2]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1$1, null, get_each_context$1$1);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme, date, isToday, highlight*/89 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[6].day + " " + /*$theme*/ctx[6].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[3] ? ' ' + /*$theme*/ctx[6].today : '') + ( /*highlight*/ctx[4] ? ' ' + /*$theme*/ctx[6].highlight : '')))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div_binding*/
	      ctx[20](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	// (60:8) {#each chunks as chunk (chunk.event)}
	function create_each_block$1$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$2({
	    props: {
	      chunk: /*chunk*/ctx[21]
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty & /*chunks*/4) event_changes.chunk = /*chunk*/ctx[21];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	}
	function create_fragment$1$3(ctx) {
	  let if_block_anchor;
	  let current;
	  let if_block = /*chunks*/ctx[2].length && create_if_block$1$2(ctx);
	  return {
	    c() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if ( /*chunks*/ctx[2].length) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*chunks*/4) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$1$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	}
	function instance$1$3($$self, $$props, $$invalidate) {
	  let $highlightedDates;
	  let $_today;
	  let $_events;
	  let $theme;
	  let $_interaction;
	  let $_intlListDay;
	  let $_intlListDaySide;
	  let {
	    date
	  } = $$props;
	  let {
	    _events,
	    _interaction,
	    _intlListDay,
	    _intlListDaySide,
	    _today,
	    highlightedDates,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(19, $_events = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(7, $_interaction = value));
	  component_subscribe($$self, _intlListDay, value => $$invalidate(8, $_intlListDay = value));
	  component_subscribe($$self, _intlListDaySide, value => $$invalidate(9, $_intlListDaySide = value));
	  component_subscribe($$self, _today, value => $$invalidate(18, $_today = value));
	  component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	  component_subscribe($$self, theme, value => $$invalidate(6, $theme = value));
	  let el;
	  let chunks;
	  let isToday, highlight;
	  let datetime;
	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*date, $_events, chunks*/524293) {
	      {
	        $$invalidate(2, chunks = []);
	        let start = date;
	        let end = addDay(cloneDate(date));
	        for (let event of $_events) {
	          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        sortEventChunks(chunks);
	      }
	    }
	    if ($$self.$$.dirty & /*date, $_today*/262145) {
	      $$invalidate(3, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty & /*$highlightedDates, date*/131073) {
	      $$invalidate(4, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty & /*date*/1) {
	      $$invalidate(5, datetime = toISOString(date, 10));
	    }
	    if ($$self.$$.dirty & /*el, date*/3) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource: undefined,
	          dayEl: el
	        }));
	      }
	    }
	  };
	  return [date, el, chunks, isToday, highlight, datetime, $theme, $_interaction, $_intlListDay, $_intlListDaySide, _events, _interaction, _intlListDay, _intlListDaySide, _today, highlightedDates, theme, $highlightedDates, $_today, $_events, div_binding];
	}
	let Day$2 = class Day extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$3, create_fragment$1$3, safe_not_equal, {
	      date: 0
	    });
	  }
	};

	/* packages/list/src/View.svelte generated by Svelte v4.2.8 */

	function get_each_context$7(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[15] = list[i];
	  return child_ctx;
	}

	// (45:0) {:else}
	function create_else_block$1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$_viewDates*/2) {
	        each_value = ensure_array_like( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$7(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$7(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (41:0) {#if noEvents}
	function create_if_block$4(ctx) {
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      attr(div, "class", div_class_value = /*$theme*/ctx[3].noEvents);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[0])), listen(div, "click", /*handleClick*/ctx[10])];
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme*/8 && div_class_value !== (div_class_value = /*$theme*/ctx[3].noEvents)) {
	        attr(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/1) setContent_action.update.call(null, /*content*/ctx[0]);
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	// (46:4) {#each $_viewDates as date}
	function create_each_block$7(ctx) {
	  let day;
	  let current;
	  day = new Day$2({
	    props: {
	      date: /*date*/ctx[15]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*$_viewDates*/2) day_changes.date = /*date*/ctx[15];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}

	// (40:0) <Body>
	function create_default_slot$3(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block$4, create_else_block$1];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*noEvents*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	}
	function create_fragment$a(ctx) {
	  let body;
	  let current;
	  body = new Body$1({
	    props: {
	      $$slots: {
	        default: [create_default_slot$3]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      create_component(body.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p(ctx, _ref3) {
	      let [dirty] = _ref3;
	      const body_changes = {};
	      if (dirty & /*$$scope, $theme, content, noEvents, $_viewDates*/262159) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(body, detaching);
	    }
	  };
	}
	function instance$a($$self, $$props, $$invalidate) {
	  let $_view;
	  let $noEventsClick;
	  let $noEventsContent;
	  let $_events;
	  let $_viewDates;
	  let $theme;
	  let {
	    _events,
	    _view,
	    _viewDates,
	    noEventsClick,
	    noEventsContent,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(12, $_events = value));
	  component_subscribe($$self, _view, value => $$invalidate(13, $_view = value));
	  component_subscribe($$self, _viewDates, value => $$invalidate(1, $_viewDates = value));
	  component_subscribe($$self, noEventsClick, value => $$invalidate(14, $noEventsClick = value));
	  component_subscribe($$self, noEventsContent, value => $$invalidate(11, $noEventsContent = value));
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  let noEvents, content;
	  function handleClick(jsEvent) {
	    if (is_function($noEventsClick)) {
	      $noEventsClick({
	        jsEvent,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_viewDates, $_events*/4098) {
	      {
	        $$invalidate(2, noEvents = true);
	        if ($_viewDates.length) {
	          let start = $_viewDates[0];
	          let end = addDay(cloneDate($_viewDates[$_viewDates.length - 1]));
	          for (let event of $_events) {
	            if (!bgEvent(event.display) && event.start < end && event.end > start) {
	              $$invalidate(2, noEvents = false);
	              break;
	            }
	          }
	        }
	      }
	    }
	    if ($$self.$$.dirty & /*$noEventsContent, content*/2049) {
	      {
	        $$invalidate(0, content = is_function($noEventsContent) ? $noEventsContent() : $noEventsContent);
	        if (typeof content === 'string') {
	          $$invalidate(0, content = {
	            html: content
	          });
	        }
	      }
	    }
	  };
	  return [content, $_viewDates, noEvents, $theme, _events, _view, _viewDates, noEventsClick, noEventsContent, theme, handleClick, $noEventsContent, $_events];
	}
	let View$2 = class View extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
	  }
	};
	var index$4 = {
	  createOptions(options) {
	    // Common options
	    options.buttonText.listDay = 'list';
	    options.buttonText.listWeek = 'list';
	    options.buttonText.listMonth = 'list';
	    options.buttonText.listYear = 'list';
	    options.listDayFormat = {
	      weekday: 'long'
	    };
	    options.listDaySideFormat = {
	      year: 'numeric',
	      month: 'long',
	      day: 'numeric'
	    };
	    options.noEventsClick = undefined; // ec option
	    options.noEventsContent = 'No events';
	    options.theme.daySide = 'ec-day-side';
	    options.theme.eventTag = 'ec-event-tag';
	    options.theme.noEvents = 'ec-no-events';
	    options.view = 'listWeek';
	    options.views.listDay = {
	      buttonText: btnTextDay,
	      component: View$2,
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-list ec-day-view')
	    };
	    options.views.listWeek = {
	      buttonText: btnTextWeek,
	      component: View$2,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-list ec-week-view')
	    };
	    options.views.listMonth = {
	      buttonText: btnTextMonth,
	      component: View$2,
	      duration: {
	        months: 1
	      },
	      theme: themeView('ec-list ec-month-view')
	    };
	    options.views.listYear = {
	      buttonText: btnTextYear,
	      component: View$2,
	      duration: {
	        years: 1
	      },
	      theme: themeView('ec-list ec-year-view')
	    };
	  },
	  createStores(state) {
	    state._intlListDay = intl(state.locale, state.listDayFormat);
	    state._intlListDaySide = intl(state.locale, state.listDaySideFormat);
	  }
	};

	function times(state) {
	  return derived([state._slotTimeLimits, state._intlSlotLabel, state.slotDuration], _ref => {
	    let [$_slotTimeLimits, $_intlSlotLabel, $slotDuration] = _ref;
	    let large = $slotDuration.seconds >= 3600;
	    let times = [];
	    let date = setMidnight(createDate());
	    let end = cloneDate(date);
	    let i = 1;
	    addDuration(date, $_slotTimeLimits.min);
	    addDuration(end, $_slotTimeLimits.max);
	    while (date < end) {
	      times.push([toISOString(date), times.length && (i || large) ? $_intlSlotLabel.format(date) : '']);
	      addDuration(date, $slotDuration);
	      i = 1 - i;
	    }
	    return times;
	  });
	}
	function slotTimeLimits(state) {
	  return derived([state._events, state._viewDates, state.flexibleSlotTimeLimits, state.slotMinTime, state.slotMaxTime], _ref2 => {
	    let [$_events, $_viewDates, $flexibleSlotTimeLimits, $slotMinTime, $slotMaxTime] = _ref2;
	    let min$1 = createDuration($slotMinTime);
	    let max$1 = createDuration($slotMaxTime);
	    if ($flexibleSlotTimeLimits) {
	      let minMin = createDuration(min(min$1.seconds, max(0, max$1.seconds - DAY_IN_SECONDS)));
	      let maxMax = createDuration(max(max$1.seconds, minMin.seconds + DAY_IN_SECONDS));
	      let filter = is_function($flexibleSlotTimeLimits?.eventFilter) ? $flexibleSlotTimeLimits.eventFilter : event => !bgEvent(event.display);
	      loop: for (let date of $_viewDates) {
	        let start = addDuration(cloneDate(date), min$1);
	        let end = addDuration(cloneDate(date), max$1);
	        let minStart = addDuration(cloneDate(date), minMin);
	        let maxEnd = addDuration(cloneDate(date), maxMax);
	        for (let event of $_events) {
	          if (!event.allDay && filter(event) && event.start < maxEnd && event.end > minStart) {
	            if (event.start < start) {
	              let seconds = max((event.start - date) / 1000, minMin.seconds);
	              if (seconds < min$1.seconds) {
	                min$1.seconds = seconds;
	              }
	            }
	            if (event.end > end) {
	              let seconds = min((event.end - date) / 1000, maxMax.seconds);
	              if (seconds > max$1.seconds) {
	                max$1.seconds = seconds;
	              }
	            }
	            if (min$1.seconds === minMin.seconds && max$1.seconds === maxMax.seconds) {
	              break loop;
	            }
	          }
	        }
	      }
	    }
	    return {
	      min: min$1,
	      max: max$1
	    };
	  });
	}
	function groupEventChunks(chunks) {
	  if (!chunks.length) {
	    return;
	  }
	  sortEventChunks(chunks);

	  // Group
	  let group = {
	    columns: [],
	    end: chunks[0].end
	  };
	  for (let chunk of chunks) {
	    let c = 0;
	    if (chunk.start < group.end) {
	      for (; c < group.columns.length; ++c) {
	        if (group.columns[c][group.columns[c].length - 1].end <= chunk.start) {
	          break;
	        }
	      }
	      if (chunk.end > group.end) {
	        group.end = chunk.end;
	      }
	    } else {
	      group = {
	        columns: [],
	        end: chunk.end
	      };
	    }
	    if (group.columns.length < c + 1) {
	      group.columns.push([]);
	    }
	    group.columns[c].push(chunk);
	    chunk.group = group;
	    chunk.column = c;
	  }
	}
	function createAllDayContent(allDayContent) {
	  let text = 'all-day';
	  let content;
	  if (allDayContent) {
	    content = is_function(allDayContent) ? allDayContent({
	      text
	    }) : allDayContent;
	    if (typeof content === 'string') {
	      content = {
	        html: content
	      };
	    }
	  } else {
	    content = {
	      html: text
	    };
	  }
	  return content;
	}

	/* packages/time-grid/src/Section.svelte generated by Svelte v4.2.8 */
	const get_lines_slot_changes = dirty => ({});
	const get_lines_slot_context = ctx => ({});
	function get_each_context$5(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[9] = list[i];
	  return child_ctx;
	}

	// (14:4) {#each $_times as time}
	function create_each_block$5(ctx) {
	  let time_1;
	  let time_1_class_value;
	  let time_1_datetime_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      time_1 = element("time");
	      attr(time_1, "class", time_1_class_value = /*$theme*/ctx[1].time);
	      attr(time_1, "datetime", time_1_datetime_value = /*time*/ctx[9][0]);
	    },
	    m(target, anchor) {
	      insert(target, time_1, anchor);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time_1, /*time*/ctx[9][1]));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$theme*/2 && time_1_class_value !== (time_1_class_value = /*$theme*/ctx[1].time)) {
	        attr(time_1, "class", time_1_class_value);
	      }
	      if (dirty & /*$_times*/4 && time_1_datetime_value !== (time_1_datetime_value = /*time*/ctx[9][0])) {
	        attr(time_1, "datetime", time_1_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_times*/4) setContent_action.update.call(null, /*time*/ctx[9][1]);
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(time_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function create_fragment$8(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let setContent_action;
	  let t0;
	  let div1_class_value;
	  let t1;
	  let div3;
	  let div2;
	  let div2_class_value;
	  let t2;
	  let div3_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like( /*$_times*/ctx[2]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	  }
	  const lines_slot_template = /*#slots*/ctx[8].lines;
	  const lines_slot = create_slot(lines_slot_template, ctx, /*$$scope*/ctx[7], get_lines_slot_context);
	  const default_slot_template = /*#slots*/ctx[8].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[7], null);
	  return {
	    c() {
	      div1 = element("div");
	      div0 = element("div");
	      t0 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t1 = space();
	      div3 = element("div");
	      div2 = element("div");
	      if (lines_slot) lines_slot.c();
	      t2 = space();
	      if (default_slot) default_slot.c();
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[1].sidebarTitle);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[1].sidebar);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[1].lines);
	      attr(div3, "class", div3_class_value = /*$theme*/ctx[1].days);
	      attr(div3, "role", "row");
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      append(div1, t0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }
	      insert(target, t1, anchor);
	      insert(target, div3, anchor);
	      append(div3, div2);
	      if (lines_slot) {
	        lines_slot.m(div2, null);
	      }
	      append(div3, t2);
	      if (default_slot) {
	        default_slot.m(div3, null);
	      }
	      current = true;
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, div0, /*allDayText*/ctx[0]));
	        mounted = true;
	      }
	    },
	    p(ctx, _ref3) {
	      let [dirty] = _ref3;
	      if (!current || dirty & /*$theme*/2 && div0_class_value !== (div0_class_value = /*$theme*/ctx[1].sidebarTitle)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*allDayText*/1) setContent_action.update.call(null, /*allDayText*/ctx[0]);
	      if (dirty & /*$theme, $_times*/6) {
	        each_value = ensure_array_like( /*$_times*/ctx[2]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$5(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$5(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(div1, null);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	      if (!current || dirty & /*$theme*/2 && div1_class_value !== (div1_class_value = /*$theme*/ctx[1].sidebar)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (lines_slot) {
	        if (lines_slot.p && (!current || dirty & /*$$scope*/128)) {
	          update_slot_base(lines_slot, lines_slot_template, ctx, /*$$scope*/ctx[7], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[7]) : get_slot_changes(lines_slot_template, /*$$scope*/ctx[7], dirty, get_lines_slot_changes), get_lines_slot_context);
	        }
	      }
	      if (!current || dirty & /*$theme*/2 && div2_class_value !== (div2_class_value = /*$theme*/ctx[1].lines)) {
	        attr(div2, "class", div2_class_value);
	      }
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/128)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[7], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[7]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[7], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/2 && div3_class_value !== (div3_class_value = /*$theme*/ctx[1].days)) {
	        attr(div3, "class", div3_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(lines_slot, local);
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(lines_slot, local);
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	        detach(t1);
	        detach(div3);
	      }
	      destroy_each(each_blocks, detaching);
	      if (lines_slot) lines_slot.d(detaching);
	      if (default_slot) default_slot.d(detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function instance$8($$self, $$props, $$invalidate) {
	  let $allDayContent;
	  let $theme;
	  let $_times;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  let {
	    allDayContent,
	    theme,
	    _times
	  } = getContext('state');
	  component_subscribe($$self, allDayContent, value => $$invalidate(6, $allDayContent = value));
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  component_subscribe($$self, _times, value => $$invalidate(2, $_times = value));
	  let allDayText;
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$allDayContent*/64) {
	      $$invalidate(0, allDayText = createAllDayContent($allDayContent));
	    }
	  };
	  return [allDayText, $theme, $_times, allDayContent, theme, _times, $allDayContent, $$scope, slots];
	}
	class Section extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	  }
	}

	/* packages/time-grid/src/Body.svelte generated by Svelte v4.2.8 */

	function get_each_context$4(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[24] = list[i];
	  return child_ctx;
	}

	// (35:8) <Section>
	function create_default_slot$1(ctx) {
	  let current;
	  const default_slot_template = /*#slots*/ctx[16].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[18], null);
	  return {
	    c() {
	      if (default_slot) default_slot.c();
	    },
	    m(target, anchor) {
	      if (default_slot) {
	        default_slot.m(target, anchor);
	      }
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/262144)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[18], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[18]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[18], dirty, null), null);
	        }
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d(detaching) {
	      if (default_slot) default_slot.d(detaching);
	    }
	  };
	}

	// (37:16) {#each lines as line}
	function create_each_block$4(ctx) {
	  let div;
	  let div_class_value;
	  return {
	    c() {
	      div = element("div");
	      attr(div, "class", div_class_value = /*$theme*/ctx[3].line);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme*/8 && div_class_value !== (div_class_value = /*$theme*/ctx[3].line)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	    }
	  };
	}

	// (36:12) <svelte:fragment slot="lines">
	function create_lines_slot(ctx) {
	  let each_1_anchor;
	  let each_value = ensure_array_like( /*lines*/ctx[2]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	  }
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme, lines*/12) {
	        each_value = ensure_array_like( /*lines*/ctx[2]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$4(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$4(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$7(ctx) {
	  let div1;
	  let div0;
	  let section;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        lines: [create_lines_slot],
	        default: [create_default_slot$1]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      div1 = element("div");
	      div0 = element("div");
	      create_component(section.$$.fragment);
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[3].content);
	      attr(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[3].body + ( /*compact*/ctx[1] ? ' ' + /*$theme*/ctx[3].compact : '')));
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      mount_component(section, div0, null);
	      /*div1_binding*/
	      ctx[17](div1);
	      current = true;
	    },
	    p(ctx, _ref4) {
	      let [dirty] = _ref4;
	      const section_changes = {};
	      if (dirty & /*$$scope, lines, $theme*/262156) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/8 && div0_class_value !== (div0_class_value = /*$theme*/ctx[3].content)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, compact*/10 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[3].body + ( /*compact*/ctx[1] ? ' ' + /*$theme*/ctx[3].compact : '')))) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	      }
	      destroy_component(section);
	      /*div1_binding*/
	      ctx[17](null);
	    }
	  };
	}
	function instance$7($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $slotDuration;
	  let $scrollTime;
	  let $_viewDates;
	  let $_slotTimeLimits;
	  let $_times;
	  let $_bodyEl;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  let {
	    _bodyEl,
	    _viewDates,
	    _slotTimeLimits,
	    _times,
	    scrollTime,
	    slotDuration,
	    slotHeight,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(22, $_bodyEl = value));
	  component_subscribe($$self, _viewDates, value => $$invalidate(13, $_viewDates = value));
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(14, $_slotTimeLimits = value));
	  component_subscribe($$self, _times, value => $$invalidate(15, $_times = value));
	  component_subscribe($$self, scrollTime, value => $$invalidate(21, $scrollTime = value));
	  component_subscribe($$self, slotDuration, value => $$invalidate(12, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(20, $slotHeight = value));
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  let el;
	  let compact;
	  let lines = [];
	  let timeLimitMin;
	  function scrollToTime() {
	    $$invalidate(0, el.scrollTop = (($scrollTime.seconds - timeLimitMin) / $slotDuration.seconds - 0.5) * $slotHeight, el);
	  }
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(0, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*el*/1) {
	      set_store_value(_bodyEl, $_bodyEl = el, $_bodyEl);
	    }
	    if ($$self.$$.dirty & /*$slotDuration, $_times, $_slotTimeLimits*/53248) {
	      {
	        $$invalidate(1, compact = $slotDuration.seconds >= 3600);
	        $$invalidate(2, lines.length = $_times.length, lines);

	        // Use intermediate variable so that changes in _slotTimeLimits do not trigger setting the el.scrollTop
	        timeLimitMin = $_slotTimeLimits.min.seconds;
	      }
	    }
	    if ($$self.$$.dirty & /*el, $_viewDates*/8193) {
	      if (el && $_viewDates) {
	        scrollToTime();
	      }
	    }
	  };
	  return [el, compact, lines, $theme, _bodyEl, _viewDates, _slotTimeLimits, _times, scrollTime, slotDuration, slotHeight, theme, $slotDuration, $_viewDates, $_slotTimeLimits, $_times, slots, div1_binding, $$scope];
	}
	class Body extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
	  }
	}

	/* packages/time-grid/src/Event.svelte generated by Svelte v4.2.8 */

	function create_fragment$6(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[10].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      }
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	    });
	  }
	  return {
	    c() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      attr(article, "class", /*classes*/ctx[4]);
	      attr(article, "style", /*style*/ctx[5]);
	      attr(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	    },
	    m(target, anchor) {
	      insert(target, article, anchor);
	      append(article, div);
	      append(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[52](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }), listen(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }), listen(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[32]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]))) /*createHandler*/ctx[32]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[32]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[32]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "pointerdown", function () {
	          if (is_function(!bgEvent( /*display*/ctx[1]) && !helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10]))) (!bgEvent( /*display*/ctx[1]) && !helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10])).apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/1024 && switch_value !== (switch_value = /*$_interaction*/ctx[10].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[52](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$6($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $slotEventOverlap;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let $slotDuration;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    date
	  } = $$props;
	  let {
	    chunk
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClick,
	    eventDidMount,
	    eventClassNames,
	    eventMouseEnter,
	    eventMouseLeave,
	    slotEventOverlap,
	    slotDuration,
	    slotHeight,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _slotTimeLimits
	  } = getContext('state');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(40, $displayEventEnd = value));
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(47, $eventBackgroundColor = value));
	  component_subscribe($$self, eventTextColor, value => $$invalidate(44, $eventTextColor = value));
	  component_subscribe($$self, eventColor, value => $$invalidate(46, $eventColor = value));
	  component_subscribe($$self, eventContent, value => $$invalidate(39, $eventContent = value));
	  component_subscribe($$self, eventClick, value => $$invalidate(36, $eventClick = value));
	  component_subscribe($$self, eventDidMount, value => $$invalidate(54, $eventDidMount = value));
	  component_subscribe($$self, eventClassNames, value => $$invalidate(41, $eventClassNames = value));
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(8, $eventMouseEnter = value));
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(9, $eventMouseLeave = value));
	  component_subscribe($$self, slotEventOverlap, value => $$invalidate(43, $slotEventOverlap = value));
	  component_subscribe($$self, slotDuration, value => $$invalidate(51, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(49, $slotHeight = value));
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  component_subscribe($$self, _view, value => $$invalidate(37, $_view = value));
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(38, $_intlEventTime = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(10, $_interaction = value));
	  component_subscribe($$self, _iClasses, value => $$invalidate(42, $_iClasses = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(48, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(45, $_resTxtColor = value));
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(50, $_slotTimeLimits = value));
	  let el;
	  let event;
	  let display;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => interaction.action.drag(event, jsEvent, resize) : undefined;
	  }
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(34, date = $$props.date);
	    if ('chunk' in $$props) $$invalidate(35, chunk = $$props.chunk);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/16) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, display, $theme*/39 | $$self.$$.dirty[1] & /*$slotDuration, $_slotTimeLimits, chunk, date, $slotHeight, $_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, $slotEventOverlap, $_iClasses, $eventClassNames, $_view*/2096216) {
	      {
	        $$invalidate(1, display = event.display);

	        // Style
	        let step = $slotDuration.seconds / 60;
	        let offset = $_slotTimeLimits.min.seconds / 60;
	        let start = (chunk.start - date) / 1000 / 60;
	        let end = (chunk.end - date) / 1000 / 60;
	        let top = (start - offset) / step * $slotHeight;
	        let height = (end - start) / step * $slotHeight;
	        let maxHeight = ($_slotTimeLimits.max.seconds / 60 - start) / step * $slotHeight;
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `top:${top}px;` + `min-height:${height}px;` + `height:${height}px;` + `max-height:${maxHeight}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        if (!bgEvent(display) && !helperEvent(display) || ghostEvent(display)) {
	          $$invalidate(5, style += `z-index:${chunk.column + 1};` + `left:${100 / chunk.group.columns.length * chunk.column}%;` + `width:${100 / chunk.group.columns.length * ($slotEventOverlap ? 0.5 * (1 + chunk.group.columns.length - chunk.column) : 1)}%;`);
	        }

	        // Class
	        $$invalidate(4, classes = [bgEvent(display) ? $theme.bgEvent : $theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/976) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/32) {
	      // Onclick handler
	      $$invalidate(7, onclick = !bgEvent(display) && createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventBackgroundColor, eventTextColor, eventColor, eventContent, eventClick, eventDidMount, eventClassNames, eventMouseEnter, eventMouseLeave, slotEventOverlap, slotDuration, slotHeight, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _slotTimeLimits, createHandler, createDragHandler, date, chunk, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $slotEventOverlap, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, $slotHeight, $_slotTimeLimits, $slotDuration, article_binding];
	}
	let Event$1 = class Event extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
	      date: 34,
	      chunk: 35
	    }, null, [-1, -1]);
	  }
	};

	/* packages/time-grid/src/NowIndicator.svelte generated by Svelte v4.2.8 */

	function create_fragment$5(ctx) {
	  let div;
	  let div_class_value;
	  return {
	    c() {
	      div = element("div");
	      attr(div, "class", div_class_value = /*$theme*/ctx[1].nowIndicator);
	      set_style(div, "top", /*top*/ctx[0] + "px");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	    },
	    p(ctx, _ref5) {
	      let [dirty] = _ref5;
	      if (dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].nowIndicator)) {
	        attr(div, "class", div_class_value);
	      }
	      if (dirty & /*top*/1) {
	        set_style(div, "top", /*top*/ctx[0] + "px");
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	    }
	  };
	}
	function instance$5($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let $slotDuration;
	  let $_today;
	  let $_now;
	  let $theme;
	  let {
	    slotDuration,
	    slotHeight,
	    theme,
	    _now,
	    _today,
	    _slotTimeLimits
	  } = getContext('state');
	  component_subscribe($$self, slotDuration, value => $$invalidate(11, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(9, $slotHeight = value));
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  component_subscribe($$self, _now, value => $$invalidate(13, $_now = value));
	  component_subscribe($$self, _today, value => $$invalidate(12, $_today = value));
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(10, $_slotTimeLimits = value));
	  let start;
	  let top = 0;
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_now, $_today*/12288) {
	      $$invalidate(8, start = ($_now - $_today) / 1000 / 60);
	    }
	    if ($$self.$$.dirty & /*$slotDuration, $_slotTimeLimits, start, $slotHeight*/3840) {
	      {
	        // Style
	        let step = $slotDuration.seconds / 60;
	        let offset = $_slotTimeLimits.min.seconds / 60;
	        $$invalidate(0, top = (start - offset) / step * $slotHeight);
	      }
	    }
	  };
	  return [top, $theme, slotDuration, slotHeight, theme, _now, _today, _slotTimeLimits, start, $slotHeight, $_slotTimeLimits, $slotDuration, $_today, $_now];
	}
	class NowIndicator extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	  }
	}

	/* packages/time-grid/src/Day.svelte generated by Svelte v4.2.8 */

	function get_each_context$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[33] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[33] = list[i];
	  return child_ctx;
	}

	// (90:8) {#each bgChunks as chunk (chunk.event)}
	function create_each_block_1$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*chunk*/ctx[33]
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*bgChunks*/8) event_changes.chunk = /*chunk*/ctx[33];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (96:8) {#if iChunks[1]}
	function create_if_block_2$1(ctx) {
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*iChunks*/ctx[4][1]
	    }
	  });
	  return {
	    c() {
	      create_component(event.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*iChunks*/16) event_changes.chunk = /*iChunks*/ctx[4][1];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (99:8) {#each chunks as chunk (chunk.event)}
	function create_each_block$3(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*chunk*/ctx[33]
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*chunks*/4) event_changes.chunk = /*chunk*/ctx[33];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (103:8) {#if iChunks[0] && !iChunks[0].event.allDay}
	function create_if_block_1$1(ctx) {
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*iChunks*/ctx[4][0]
	    }
	  });
	  return {
	    c() {
	      create_component(event.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*iChunks*/16) event_changes.chunk = /*iChunks*/ctx[4][0];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(event, detaching);
	    }
	  };
	}

	// (109:8) {#if $nowIndicator && isToday}
	function create_if_block$2$1(ctx) {
	  let nowindicator;
	  let current;
	  nowindicator = new NowIndicator({});
	  return {
	    c() {
	      create_component(nowindicator.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(nowindicator, target, anchor);
	      current = true;
	    },
	    i(local) {
	      if (current) return;
	      transition_in(nowindicator.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(nowindicator.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(nowindicator, detaching);
	    }
	  };
	}
	function create_fragment$4$1(ctx) {
	  let div3;
	  let div0;
	  let each_blocks_1 = [];
	  let each0_lookup = new Map();
	  let div0_class_value;
	  let t0;
	  let div1;
	  let t1;
	  let each_blocks = [];
	  let each1_lookup = new Map();
	  let t2;
	  let div1_class_value;
	  let t3;
	  let div2;
	  let div2_class_value;
	  let div3_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value_1 = ensure_array_like( /*bgChunks*/ctx[3]);
	  const get_key = ctx => /*chunk*/ctx[33].event;
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
	    let key = get_key(child_ctx);
	    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$1(key, child_ctx));
	  }
	  let if_block0 = /*iChunks*/ctx[4][1] && create_if_block_2$1(ctx);
	  let each_value = ensure_array_like( /*chunks*/ctx[2]);
	  const get_key_1 = ctx => /*chunk*/ctx[33].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$3(ctx, each_value, i);
	    let key = get_key_1(child_ctx);
	    each1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	  }
	  let if_block1 = /*iChunks*/ctx[4][0] && ! /*iChunks*/ctx[4][0].event.allDay && create_if_block_1$1(ctx);
	  let if_block2 = /*$nowIndicator*/ctx[9] && /*isToday*/ctx[5] && create_if_block$2$1();
	  return {
	    c() {
	      div3 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        each_blocks_1[i].c();
	      }
	      t0 = space();
	      div1 = element("div");
	      if (if_block0) if_block0.c();
	      t1 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t2 = space();
	      if (if_block1) if_block1.c();
	      t3 = space();
	      div2 = element("div");
	      if (if_block2) if_block2.c();
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[7].bgEvents);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[7].events);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[7].extra);
	      attr(div3, "class", div3_class_value = "" + ( /*$theme*/ctx[7].day + " " + /*$theme*/ctx[7].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[7].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[7].highlight : '')));
	      attr(div3, "role", "cell");
	    },
	    m(target, anchor) {
	      insert(target, div3, anchor);
	      append(div3, div0);
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        if (each_blocks_1[i]) {
	          each_blocks_1[i].m(div0, null);
	        }
	      }
	      append(div3, t0);
	      append(div3, div1);
	      if (if_block0) if_block0.m(div1, null);
	      append(div1, t1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }
	      append(div1, t2);
	      if (if_block1) if_block1.m(div1, null);
	      append(div3, t3);
	      append(div3, div2);
	      if (if_block2) if_block2.m(div2, null);
	      /*div3_binding*/
	      ctx[29](div3);
	      current = true;
	      if (!mounted) {
	        dispose = [listen(div3, "pointerenter", function () {
	          if (is_function( /*createPointerEnterHandler*/ctx[20]( /*$_interaction*/ctx[8]))) /*createPointerEnterHandler*/ctx[20]( /*$_interaction*/ctx[8]).apply(this, arguments);
	        }), listen(div3, "pointerleave", function () {
	          if (is_function( /*$_interaction*/ctx[8].pointer?.leave)) /*$_interaction*/ctx[8].pointer?.leave.apply(this, arguments);
	        }), listen(div3, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[8].action?.select)) /*$_interaction*/ctx[8].action?.select.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*date, bgChunks*/9) {
	        each_value_1 = ensure_array_like( /*bgChunks*/ctx[3]);
	        group_outros();
	        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div0_class_value !== (div0_class_value = /*$theme*/ctx[7].bgEvents)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if ( /*iChunks*/ctx[4][1]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	          if (dirty[0] & /*iChunks*/16) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_2$1(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div1, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, () => {
	          if_block0 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*date, chunks*/5) {
	        each_value = ensure_array_like( /*chunks*/ctx[2]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, outro_and_destroy_block, create_each_block$3, t2, get_each_context$3);
	        check_outros();
	      }
	      if ( /*iChunks*/ctx[4][0] && ! /*iChunks*/ctx[4][0].event.allDay) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*iChunks*/16) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_1$1(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div1, null);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div1_class_value !== (div1_class_value = /*$theme*/ctx[7].events)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if ( /*$nowIndicator*/ctx[9] && /*isToday*/ctx[5]) {
	        if (if_block2) {
	          if (dirty[0] & /*$nowIndicator, isToday*/544) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block$2$1();
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div2, null);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, () => {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div2_class_value !== (div2_class_value = /*$theme*/ctx[7].extra)) {
	        attr(div2, "class", div2_class_value);
	      }
	      if (!current || dirty[0] & /*$theme, date, isToday, highlight*/225 && div3_class_value !== (div3_class_value = "" + ( /*$theme*/ctx[7].day + " " + /*$theme*/ctx[7].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[7].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[7].highlight : '')))) {
	        attr(div3, "class", div3_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks_1[i]);
	      }
	      transition_in(if_block0);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      transition_in(if_block1);
	      transition_in(if_block2);
	      current = true;
	    },
	    o(local) {
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        transition_out(each_blocks_1[i]);
	      }
	      transition_out(if_block0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      transition_out(if_block1);
	      transition_out(if_block2);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div3);
	      }
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        each_blocks_1[i].d();
	      }
	      if (if_block0) if_block0.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      /*div3_binding*/
	      ctx[29](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$4$1($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $slotDuration;
	  let $_slotTimeLimits;
	  let $highlightedDates;
	  let $_today;
	  let $_iEvents;
	  let $_events;
	  let $theme;
	  let $_interaction;
	  let $nowIndicator;
	  let {
	    date
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    highlightedDates,
	    nowIndicator,
	    slotDuration,
	    slotHeight,
	    theme,
	    _interaction,
	    _today,
	    _slotTimeLimits
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(28, $_events = value));
	  component_subscribe($$self, _iEvents, value => $$invalidate(27, $_iEvents = value));
	  component_subscribe($$self, highlightedDates, value => $$invalidate(25, $highlightedDates = value));
	  component_subscribe($$self, nowIndicator, value => $$invalidate(9, $nowIndicator = value));
	  component_subscribe($$self, slotDuration, value => $$invalidate(31, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(30, $slotHeight = value));
	  component_subscribe($$self, theme, value => $$invalidate(7, $theme = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  component_subscribe($$self, _today, value => $$invalidate(26, $_today = value));
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(24, $_slotTimeLimits = value));
	  let el;
	  let chunks,
	    bgChunks,
	    iChunks = [];
	  let isToday, highlight;
	  let start, end;
	  function dateFromPoint(y) {
	    y -= rect(el).top;
	    return {
	      allDay: false,
	      date: addDuration(addDuration(cloneDate(date), $_slotTimeLimits.min), $slotDuration, floor(y / $slotHeight)),
	      resource,
	      dayEl: el
	    };
	  }
	  function createPointerEnterHandler(interaction) {
	    return interaction.pointer ? jsEvent => interaction.pointer.enterTimeGrid(date, el, jsEvent, resource) : undefined;
	  }
	  function div3_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('resource' in $$props) $$invalidate(21, resource = $$props.resource);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*date, $_slotTimeLimits*/16777217) {
	      {
	        $$invalidate(22, start = addDuration(cloneDate(date), $_slotTimeLimits.min));
	        $$invalidate(23, end = addDuration(cloneDate(date), $_slotTimeLimits.max));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_events, start, end, resource, bgChunks, chunks*/283115532) {
	      {
	        $$invalidate(2, chunks = []);
	        $$invalidate(3, bgChunks = []);
	        for (let event of $_events) {
	          if (!event.allDay && eventIntersects(event, start, end, resource, true)) {
	            let chunk = createEventChunk(event, start, end);
	            switch (event.display) {
	              case 'background':
	                bgChunks.push(chunk);
	                break;
	              default:
	                chunks.push(chunk);
	            }
	          }
	        }
	        groupEventChunks(chunks);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_iEvents, start, end, resource*/148897792) {
	      $$invalidate(4, iChunks = $_iEvents.map(event => event && eventIntersects(event, start, end, resource, true) ? createEventChunk(event, start, end) : null));
	    }
	    if ($$self.$$.dirty[0] & /*date, $_today*/67108865) {
	      $$invalidate(5, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty[0] & /*$highlightedDates, date*/33554433) {
	      $$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty[0] & /*el*/2) {
	      if (el) {
	        setPayload(el, dateFromPoint);
	      }
	    }
	  };
	  return [date, el, chunks, bgChunks, iChunks, isToday, highlight, $theme, $_interaction, $nowIndicator, _events, _iEvents, highlightedDates, nowIndicator, slotDuration, slotHeight, theme, _interaction, _today, _slotTimeLimits, createPointerEnterHandler, resource, start, end, $_slotTimeLimits, $highlightedDates, $_today, $_iEvents, $_events, div3_binding];
	}
	let Day$1 = class Day extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$4$1, create_fragment$4$1, safe_not_equal, {
	      date: 0,
	      resource: 21
	    }, null, [-1, -1]);
	  }
	};

	/* packages/time-grid/src/all-day/Event.svelte generated by Svelte v4.2.8 */

	function create_fragment$3$1(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[10].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      }
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	    });
	  }
	  return {
	    c() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      attr(article, "class", /*classes*/ctx[4]);
	      attr(article, "style", /*style*/ctx[5]);
	      attr(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	    },
	    m(target, anchor) {
	      insert(target, article, anchor);
	      append(article, div);
	      append(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[46](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }), listen(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }), listen(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[28]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]))) /*createHandler*/ctx[28]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[28]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[28]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }), listen(article, "pointerdown", function () {
	          if (is_function(!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10]))) (!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10])).apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/1024 && switch_value !== (switch_value = /*$_interaction*/ctx[10].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[29]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[46](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$3$1($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    chunk
	  } = $$props;
	  let {
	    longChunks = {}
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor
	  } = getContext('state');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(38, $displayEventEnd = value));
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(44, $eventBackgroundColor = value));
	  component_subscribe($$self, eventTextColor, value => $$invalidate(41, $eventTextColor = value));
	  component_subscribe($$self, eventClick, value => $$invalidate(34, $eventClick = value));
	  component_subscribe($$self, eventColor, value => $$invalidate(43, $eventColor = value));
	  component_subscribe($$self, eventContent, value => $$invalidate(37, $eventContent = value));
	  component_subscribe($$self, eventClassNames, value => $$invalidate(39, $eventClassNames = value));
	  component_subscribe($$self, eventDidMount, value => $$invalidate(48, $eventDidMount = value));
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(8, $eventMouseEnter = value));
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(9, $eventMouseLeave = value));
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  component_subscribe($$self, _view, value => $$invalidate(35, $_view = value));
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(36, $_intlEventTime = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(10, $_interaction = value));
	  component_subscribe($$self, _iClasses, value => $$invalidate(40, $_iClasses = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(45, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(42, $_resTxtColor = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let margin = 1;
	  let display;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => interaction.action.drag(event, jsEvent, resize) : undefined;
	  }
	  function reposition() {
	    if (!el || previewEvent(display)) {
	      return;
	    }
	    $$invalidate(33, margin = repositionEvent(chunk, longChunks, height(el)));
	  }
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(30, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(31, longChunks = $$props.longChunks);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*chunk*/1073741824) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, chunk, style, $theme*/1073741861 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, margin, $_iClasses, $eventClassNames, $_view*/32532) {
	      {
	        $$invalidate(1, display = event.display);

	        // Class & Style
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        $$invalidate(4, classes = [$theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*chunk, $theme*/1073741828 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime, $_view*/240) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/8) {
	      // Onclick handler
	      $$invalidate(7, onclick = createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, createHandler, createDragHandler, chunk, longChunks, reposition, margin, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	class Event extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3$1, create_fragment$3$1, safe_not_equal, {
	      chunk: 30,
	      longChunks: 31,
	      reposition: 32
	    }, null, [-1, -1]);
	  }
	  get reposition() {
	    return this.$$.ctx[32];
	  }
	}

	/* packages/time-grid/src/all-day/Day.svelte generated by Svelte v4.2.8 */

	function get_each_context$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  child_ctx[22] = list;
	  child_ctx[23] = i;
	  return child_ctx;
	}

	// (54:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
	function create_if_block$1$1(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event({
	    props: {
	      chunk: /*iChunks*/ctx[2][0]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[8].events + " " + /*$theme*/ctx[8].preview));
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const event_changes = {};
	      if (dirty & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][0];
	      event.$set(event_changes);
	      if (!current || dirty & /*$theme*/256 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[8].events + " " + /*$theme*/ctx[8].preview))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(event);
	    }
	  };
	}

	// (60:8) {#each dayChunks as chunk, i (chunk.event)}
	function create_each_block$2(key_1, ctx) {
	  let first;
	  let event;
	  let i = /*i*/ctx[23];
	  let current;
	  const assign_event = () => /*event_binding*/ctx[19](event, i);
	  const unassign_event = () => /*event_binding*/ctx[19](null, i);
	  let event_props = {
	    chunk: /*chunk*/ctx[21],
	    longChunks: /*longChunks*/ctx[1]
	  };
	  event = new Event({
	    props: event_props
	  });
	  assign_event();
	  return {
	    key: key_1,
	    first: null,
	    c() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (i !== /*i*/ctx[23]) {
	        unassign_event();
	        i = /*i*/ctx[23];
	        assign_event();
	      }
	      const event_changes = {};
	      if (dirty & /*dayChunks*/16) event_changes.chunk = /*chunk*/ctx[21];
	      if (dirty & /*longChunks*/2) event_changes.longChunks = /*longChunks*/ctx[1];
	      event.$set(event_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(first);
	      }
	      unassign_event();
	      destroy_component(event, detaching);
	    }
	  };
	}
	function create_fragment$2$1(ctx) {
	  let div1;
	  let show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	  let t;
	  let div0;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let if_block = show_if && create_if_block$1$1(ctx);
	  let each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	  const get_key = ctx => /*chunk*/ctx[21].event;
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$2(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	  }
	  return {
	    c() {
	      div1 = element("div");
	      if (if_block) if_block.c();
	      t = space();
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[8].events);
	      attr(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[8].day + " " + /*$theme*/ctx[8].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[8].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[8].highlight : '')));
	      attr(div1, "role", "cell");
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      if (if_block) if_block.m(div1, null);
	      append(div1, t);
	      append(div1, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }

	      /*div1_binding*/
	      ctx[20](div1);
	      current = true;
	      if (!mounted) {
	        dispose = [listen(window, "resize", /*reposition*/ctx[14]), listen(div1, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[9].action?.select)) /*$_interaction*/ctx[9].action?.select.apply(this, arguments);
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, _ref6) {
	      let [dirty] = _ref6;
	      ctx = new_ctx;
	      if (dirty & /*iChunks, date*/5) show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	      if (show_if) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*iChunks, date*/5) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$1$1(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(div1, t);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      if (dirty & /*dayChunks, longChunks, refs*/146) {
	        each_value = ensure_array_like( /*dayChunks*/ctx[4]);
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/256 && div0_class_value !== (div0_class_value = /*$theme*/ctx[8].events)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, date, isToday, highlight*/353 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[8].day + " " + /*$theme*/ctx[8].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[8].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[8].highlight : '')))) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	      }
	      if (if_block) if_block.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div1_binding*/
	      ctx[20](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function instance$2$2($$self, $$props, $$invalidate) {
	  let $highlightedDates;
	  let $_today;
	  let $theme;
	  let $_interaction;
	  let {
	    date
	  } = $$props;
	  let {
	    chunks
	  } = $$props;
	  let {
	    longChunks
	  } = $$props;
	  let {
	    iChunks = []
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    highlightedDates,
	    theme,
	    _interaction,
	    _today
	  } = getContext('state');
	  component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	  component_subscribe($$self, theme, value => $$invalidate(8, $theme = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(9, $_interaction = value));
	  component_subscribe($$self, _today, value => $$invalidate(18, $_today = value));
	  let el;
	  let dayChunks;
	  let isToday;
	  let highlight;
	  let refs = [];
	  function reposition() {
	    $$invalidate(7, refs.length = dayChunks.length, refs);
	    for (let ref of refs) {
	      ref && ref.reposition && ref.reposition();
	    }
	  }
	  afterUpdate(reposition);
	  function event_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(7, refs);
	    });
	  }
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(15, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	    if ('resource' in $$props) $$invalidate(16, resource = $$props.resource);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*chunks, date, dayChunks*/32785) {
	      {
	        $$invalidate(4, dayChunks = []);
	        for (let chunk of chunks) {
	          if (datesEqual(chunk.date, date)) {
	            dayChunks.push(chunk);
	          }
	        }
	      }
	    }
	    if ($$self.$$.dirty & /*date, $_today*/262145) {
	      $$invalidate(5, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty & /*$highlightedDates, date*/131073) {
	      $$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty & /*el, date, resource*/65545) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource,
	          dayEl: el
	        }));
	      }
	    }
	  };
	  return [date, longChunks, iChunks, el, dayChunks, isToday, highlight, refs, $theme, $_interaction, highlightedDates, theme, _interaction, _today, reposition, chunks, resource, $highlightedDates, $_today, event_binding, div1_binding];
	}
	class Day extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$2, create_fragment$2$1, safe_not_equal, {
	      date: 0,
	      chunks: 15,
	      longChunks: 1,
	      iChunks: 2,
	      resource: 16
	    });
	  }
	}

	/* packages/time-grid/src/all-day/Week.svelte generated by Svelte v4.2.8 */

	function get_each_context$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[14] = list[i];
	  return child_ctx;
	}

	// (44:0) {#each dates as date}
	function create_each_block$1(ctx) {
	  let day;
	  let current;
	  day = new Day({
	    props: {
	      date: /*date*/ctx[14],
	      chunks: /*chunks*/ctx[2],
	      longChunks: /*longChunks*/ctx[3],
	      iChunks: /*iChunks*/ctx[4],
	      resource: /*resource*/ctx[1]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*dates*/1) day_changes.date = /*date*/ctx[14];
	      if (dirty & /*chunks*/4) day_changes.chunks = /*chunks*/ctx[2];
	      if (dirty & /*longChunks*/8) day_changes.longChunks = /*longChunks*/ctx[3];
	      if (dirty & /*iChunks*/16) day_changes.iChunks = /*iChunks*/ctx[4];
	      if (dirty & /*resource*/2) day_changes.resource = /*resource*/ctx[1];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}
	function create_fragment$1$2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*dates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, _ref7) {
	      let [dirty] = _ref7;
	      if (dirty & /*dates, chunks, longChunks, iChunks, resource*/31) {
	        each_value = ensure_array_like( /*dates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function instance$1$2($$self, $$props, $$invalidate) {
	  let $hiddenDays;
	  let $_iEvents;
	  let $_events;
	  let {
	    dates
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    hiddenDays,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _events, value => $$invalidate(12, $_events = value));
	  component_subscribe($$self, _iEvents, value => $$invalidate(11, $_iEvents = value));
	  component_subscribe($$self, hiddenDays, value => $$invalidate(10, $hiddenDays = value));
	  let chunks,
	    longChunks,
	    iChunks = [];
	  let start;
	  let end;
	  $$self.$$set = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	    if ('resource' in $$props) $$invalidate(1, resource = $$props.resource);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*dates*/1) {
	      {
	        $$invalidate(8, start = dates[0]);
	        $$invalidate(9, end = addDay(cloneDate(dates[dates.length - 1])));
	      }
	    }
	    if ($$self.$$.dirty & /*$_events, start, end, resource, chunks, $hiddenDays*/5894) {
	      {
	        $$invalidate(2, chunks = []);
	        for (let event of $_events) {
	          if (event.allDay && event.display !== 'background' && eventIntersects(event, start, end, resource)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        $$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));
	      }
	    }
	    if ($$self.$$.dirty & /*$_iEvents, start, end, resource, $hiddenDays*/3842) {
	      $$invalidate(4, iChunks = $_iEvents.map(event => {
	        let chunk;
	        if (event && event.allDay && eventIntersects(event, start, end, resource)) {
	          chunk = createEventChunk(event, start, end);
	          prepareEventChunks([chunk], $hiddenDays);
	        } else {
	          chunk = null;
	        }
	        return chunk;
	      }));
	    }
	  };
	  return [dates, resource, chunks, longChunks, iChunks, _events, _iEvents, hiddenDays, start, end, $hiddenDays, $_iEvents, $_events];
	}
	class Week extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$2, create_fragment$1$2, safe_not_equal, {
	      dates: 0,
	      resource: 1
	    });
	  }
	}

	/* packages/time-grid/src/View.svelte generated by Svelte v4.2.8 */

	function get_each_context$6(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}

	// (14:8) {#each $_viewDates as date}
	function create_each_block_1$2(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      time = element("time");
	      t = space();
	      attr(time, "datetime", time_datetime_value = toISOString( /*date*/ctx[10], 10));
	      attr(time, "aria-label", time_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*date*/ctx[10]));
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*date*/ctx[10].getUTCDay()]));
	      attr(div, "role", "columnheader");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, time);
	      append(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[3].format( /*date*/ctx[10])));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$_viewDates*/2 && time_datetime_value !== (time_datetime_value = toISOString( /*date*/ctx[10], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (dirty & /*$_intlDayHeaderAL, $_viewDates*/6 && time_aria_label_value !== (time_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*date*/ctx[10]))) {
	        attr(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_viewDates*/10) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[3].format( /*date*/ctx[10]));
	      if (dirty & /*$theme, $_viewDates*/3 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*date*/ctx[10].getUTCDay()]))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (13:4) <Section>
	function create_default_slot_2$1(ctx) {
	  let each_1_anchor;
	  let each_value_1 = ensure_array_like( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	  }
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme, $_viewDates, $_intlDayHeaderAL, $_intlDayHeader*/15) {
	        each_value_1 = ensure_array_like( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1$2(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block_1$2(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value_1.length;
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (26:0) {#if $allDaySlot}
	function create_if_block$3(ctx) {
	  let div2;
	  let div1;
	  let section;
	  let t;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_1$1]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      div2 = element("div");
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t = space();
	      div0 = element("div");
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].hiddenScroll);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].content);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[0].allDay);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div1);
	      mount_component(section, div1, null);
	      append(div1, t);
	      append(div1, div0);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const section_changes = {};
	      if (dirty & /*$$scope, $_viewDates*/32770) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].content)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div2_class_value !== (div2_class_value = /*$theme*/ctx[0].allDay)) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      destroy_component(section);
	    }
	  };
	}

	// (29:12) <Section>
	function create_default_slot_1$1(ctx) {
	  let week;
	  let current;
	  week = new Week({
	    props: {
	      dates: /*$_viewDates*/ctx[1]
	    }
	  });
	  return {
	    c() {
	      create_component(week.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const week_changes = {};
	      if (dirty & /*$_viewDates*/2) week_changes.dates = /*$_viewDates*/ctx[1];
	      week.$set(week_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	}

	// (37:0) {#each $_viewDates as date}
	function create_each_block$6(ctx) {
	  let day;
	  let current;
	  day = new Day$1({
	    props: {
	      date: /*date*/ctx[10]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*$_viewDates*/2) day_changes.date = /*date*/ctx[10];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}

	// (36:0) <Body>
	function create_default_slot$2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$_viewDates*/2) {
	        each_value = ensure_array_like( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$6(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$6(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$9(ctx) {
	  let div1;
	  let section;
	  let t0;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let t1;
	  let t2;
	  let body;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_2$1]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  let if_block = /*$allDaySlot*/ctx[4] && create_if_block$3(ctx);
	  body = new Body({
	    props: {
	      $$slots: {
	        default: [create_default_slot$2]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t0 = space();
	      div0 = element("div");
	      t1 = space();
	      if (if_block) if_block.c();
	      t2 = space();
	      create_component(body.$$.fragment);
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[0].hiddenScroll);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[0].header);
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      mount_component(section, div1, null);
	      append(div1, t0);
	      append(div1, div0);
	      insert(target, t1, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, t2, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p(ctx, _ref8) {
	      let [dirty] = _ref8;
	      const section_changes = {};
	      if (dirty & /*$$scope, $_viewDates, $theme, $_intlDayHeaderAL, $_intlDayHeader*/32783) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].header)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if ( /*$allDaySlot*/ctx[4]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*$allDaySlot*/16) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$3(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t2.parentNode, t2);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      const body_changes = {};
	      if (dirty & /*$$scope, $_viewDates*/32770) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      transition_in(if_block);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(section.$$.fragment, local);
	      transition_out(if_block);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	        detach(t1);
	        detach(t2);
	      }
	      destroy_component(section);
	      if (if_block) if_block.d(detaching);
	      destroy_component(body, detaching);
	    }
	  };
	}
	function instance$9($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_viewDates;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let $allDaySlot;
	  let {
	    _viewDates,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _viewDates, value => $$invalidate(1, $_viewDates = value));
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(2, $_intlDayHeaderAL = value));
	  component_subscribe($$self, allDaySlot, value => $$invalidate(4, $allDaySlot = value));
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  return [$theme, $_viewDates, $_intlDayHeaderAL, $_intlDayHeader, $allDaySlot, _viewDates, _intlDayHeader, _intlDayHeaderAL, allDaySlot, theme];
	}
	let View$1 = class View extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
	  }
	};
	var index$3 = {
	  createOptions(options) {
	    // Common options
	    options.buttonText.timeGridDay = 'day';
	    options.buttonText.timeGridWeek = 'week';
	    options.view = 'timeGridWeek';
	    options.views.timeGridDay = {
	      buttonText: btnTextDay,
	      component: View$1,
	      dayHeaderFormat: {
	        weekday: 'long'
	      },
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-time-grid ec-day-view'),
	      titleFormat: {
	        year: 'numeric',
	        month: 'long',
	        day: 'numeric'
	      }
	    };
	    options.views.timeGridWeek = {
	      buttonText: btnTextWeek,
	      component: View$1,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-time-grid ec-week-view')
	    };
	  },
	  createStores(state) {
	    state._slotTimeLimits = slotTimeLimits(state); // flexible limits
	    state._times = times(state);
	  }
	};

	function createResources(input) {
	  return input.map(resource => ({
	    id: String(resource.id),
	    title: resource.title || '',
	    titleHTML: resource.titleHTML || '',
	    eventBackgroundColor: resource.eventBackgroundColor,
	    eventTextColor: resource.eventTextColor
	  }));
	}
	function viewResources(state) {
	  return derived([state.resources, state.filterResourcesWithEvents, state._events, state._activeRange], _ref => {
	    let [$resources, $filterResourcesWithEvents, $_events, $_activeRange] = _ref;
	    let result = $resources;
	    if ($filterResourcesWithEvents) {
	      result = $resources.filter(resource => {
	        for (let event of $_events) {
	          if (event.display !== 'background' && event.resourceIds.includes(resource.id) && event.start < $_activeRange.end && event.end > $_activeRange.start) {
	            return true;
	          }
	        }
	        return false;
	      });
	    }
	    if (!result.length) {
	      result = createResources([{}]);
	    }
	    return result;
	  });
	}

	/* packages/resource-time-grid/src/Label.svelte generated by Svelte v4.2.8 */

	function create_fragment$1$1(ctx) {
	  let span;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      span = element("span");
	      attr(span, "aria-label", /*ariaLabel*/ctx[2]);
	    },
	    m(target, anchor) {
	      insert(target, span, anchor);
	      /*span_binding*/
	      ctx[9](span);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, span, /*content*/ctx[1]));
	        mounted = true;
	      }
	    },
	    p(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if (dirty & /*ariaLabel*/4) {
	        attr(span, "aria-label", /*ariaLabel*/ctx[2]);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/2) setContent_action.update.call(null, /*content*/ctx[1]);
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(span);
	      }

	      /*span_binding*/
	      ctx[9](null);
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function instance$2$1($$self, $$props, $$invalidate) {
	  let $_intlDayHeaderAL;
	  let $resourceLabelDidMount;
	  let $resourceLabelContent;
	  let {
	    resource
	  } = $$props;
	  let {
	    date = undefined
	  } = $$props;
	  let {
	    resourceLabelContent,
	    resourceLabelDidMount,
	    _intlDayHeaderAL
	  } = getContext('state');
	  component_subscribe($$self, resourceLabelContent, value => $$invalidate(8, $resourceLabelContent = value));
	  component_subscribe($$self, resourceLabelDidMount, value => $$invalidate(11, $resourceLabelDidMount = value));
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(10, $_intlDayHeaderAL = value));
	  const dispatch = createEventDispatcher();
	  let el;
	  let content;
	  let ariaLabel;
	  onMount(() => {
	    if (is_function($resourceLabelDidMount)) {
	      $resourceLabelDidMount({
	        resource,
	        date: date ? toLocalDate(date) : undefined,
	        el
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (date) {
	      $$invalidate(2, ariaLabel = $_intlDayHeaderAL.format(date) + ', ' + el.innerText);
	    } else {
	      $$invalidate(2, ariaLabel = undefined);
	      dispatch('text', el.innerText);
	    }
	  });
	  function span_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(0, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('resource' in $$props) $$invalidate(6, resource = $$props.resource);
	    if ('date' in $$props) $$invalidate(7, date = $$props.date);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$resourceLabelContent, resource, date*/448) {
	      // Content
	      if ($resourceLabelContent) {
	        $$invalidate(1, content = is_function($resourceLabelContent) ? $resourceLabelContent({
	          resource,
	          date: date ? toLocalDate(date) : undefined
	        }) : $resourceLabelContent);
	      } else {
	        $$invalidate(1, content = resource.titleHTML ? {
	          html: resource.titleHTML
	        } : resource.title);
	      }
	    }
	  };
	  return [el, content, ariaLabel, resourceLabelContent, resourceLabelDidMount, _intlDayHeaderAL, resource, date, $resourceLabelContent, span_binding];
	}
	class Label extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2$1, create_fragment$1$1, safe_not_equal, {
	      resource: 6,
	      date: 7
	    });
	  }
	}

	/* packages/resource-time-grid/src/View.svelte generated by Svelte v4.2.8 */

	function get_each_context(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[17] = list[i];
	  return child_ctx;
	}
	function get_each_context_1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}
	function get_each_context_4(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[26] = list[i];
	  return child_ctx;
	}
	function get_each_context_2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[23] = list[i];
	  return child_ctx;
	}
	function get_each_context_3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[26] = list[i];
	  return child_ctx;
	}
	function get_each_context_5(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[17] = list[i];
	  child_ctx[32] = i;
	  return child_ctx;
	}
	function get_each_context_6(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	// (28:16) {:else}
	function create_else_block_2(ctx) {
	  let div;
	  let label;
	  let div_class_value;
	  let current;
	  function text_handler() {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    return /*text_handler*/ctx[16]( /*i*/ctx[32], ...args);
	  }
	  label = new Label({
	    props: {
	      resource: /*item0*/ctx[17]
	    }
	  });
	  label.$on("text", text_handler);
	  return {
	    c() {
	      div = element("div");
	      create_component(label.$$.fragment);
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].day);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(label, div, null);
	      current = true;
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      const label_changes = {};
	      if (dirty[0] & /*loops*/8) label_changes.resource = /*item0*/ctx[17];
	      label.$set(label_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].day)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(label.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(label.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(label);
	    }
	  };
	}

	// (20:16) {#if $datesAboveResources}
	function create_if_block_4(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      time = element("time");
	      attr(time, "datetime", time_datetime_value = toISOString( /*item0*/ctx[17], 10));
	      attr(time, "aria-label", time_aria_label_value = /*$_intlDayHeaderAL*/ctx[6].format( /*item0*/ctx[17]));
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item0*/ctx[17].getUTCDay()]));
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, time);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[7].format( /*item0*/ctx[17])));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*loops*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*item0*/ctx[17], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (dirty[0] & /*$_intlDayHeaderAL, loops*/72 && time_aria_label_value !== (time_aria_label_value = /*$_intlDayHeaderAL*/ctx[6].format( /*item0*/ctx[17]))) {
	        attr(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayHeader, loops*/136) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[7].format( /*item0*/ctx[17]));
	      if (dirty[0] & /*$theme, loops*/40 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item0*/ctx[17].getUTCDay()]))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (33:16) {#if loops[1].length > 1}
	function create_if_block_2(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let each_value_6 = ensure_array_like( /*loops*/ctx[3][1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_6.length; i += 1) {
	    each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].days);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252) {
	        each_value_6 = ensure_array_like( /*loops*/ctx[3][1]);
	        let i;
	        for (i = 0; i < each_value_6.length; i += 1) {
	          const child_ctx = get_each_context_6(ctx, each_value_6, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_6(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value_6.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].days)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_6.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (40:28) {:else}
	function create_else_block_1(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      time = element("time");
	      t = space();
	      attr(time, "datetime", time_datetime_value = toISOString( /*item1*/ctx[20], 10));
	      attr(time, "aria-label", time_aria_label_value = "" + ( /*resourceLabels*/ctx[4][/*i*/ctx[32]] + /*$_intlDayHeaderAL*/ctx[6].format( /*item1*/ctx[20])));
	      attr(div, "class", div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item1*/ctx[20].getUTCDay()]));
	      attr(div, "role", "columnheader");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, time);
	      append(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[7].format( /*item1*/ctx[20])));
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*loops*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*item1*/ctx[20], 10))) {
	        attr(time, "datetime", time_datetime_value);
	      }
	      if (dirty[0] & /*resourceLabels, $_intlDayHeaderAL, loops*/88 && time_aria_label_value !== (time_aria_label_value = "" + ( /*resourceLabels*/ctx[4][/*i*/ctx[32]] + /*$_intlDayHeaderAL*/ctx[6].format( /*item1*/ctx[20])))) {
	        attr(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayHeader, loops*/136) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[7].format( /*item1*/ctx[20]));
	      if (dirty[0] & /*$theme, loops*/40 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item1*/ctx[20].getUTCDay()]))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}

	// (36:28) {#if $datesAboveResources}
	function create_if_block_3(ctx) {
	  let div;
	  let label;
	  let t;
	  let div_class_value;
	  let current;
	  label = new Label({
	    props: {
	      resource: /*item1*/ctx[20],
	      date: /*item0*/ctx[17]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(label.$$.fragment);
	      t = space();
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].day);
	      attr(div, "role", "columnheader");
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(label, div, null);
	      append(div, t);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const label_changes = {};
	      if (dirty[0] & /*loops*/8) label_changes.resource = /*item1*/ctx[20];
	      if (dirty[0] & /*loops*/8) label_changes.date = /*item0*/ctx[17];
	      label.$set(label_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].day)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(label.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(label.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(label);
	    }
	  };
	}

	// (35:24) {#each loops[1] as item1}
	function create_each_block_6(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block_3, create_else_block_1];
	  const if_blocks = [];
	  function select_block_type_1(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type_1(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type_1(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	}

	// (18:8) {#each loops[0] as item0, i}
	function create_each_block_5(ctx) {
	  let div;
	  let current_block_type_index;
	  let if_block0;
	  let t0;
	  let t1;
	  let div_class_value;
	  let current;
	  const if_block_creators = [create_if_block_4, create_else_block_2];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  let if_block1 = /*loops*/ctx[3][1].length > 1 && create_if_block_2(ctx);
	  return {
	    c() {
	      div = element("div");
	      if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      if_blocks[current_block_type_index].m(div, null);
	      append(div, t0);
	      if (if_block1) if_block1.m(div, null);
	      append(div, t1);
	      current = true;
	    },
	    p(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block0 = if_blocks[current_block_type_index];
	        if (!if_block0) {
	          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block0.c();
	        } else {
	          if_block0.p(ctx, dirty);
	        }
	        transition_in(if_block0, 1);
	        if_block0.m(div, t0);
	      }
	      if ( /*loops*/ctx[3][1].length > 1) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*loops*/8) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_2(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div, t1);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      if_blocks[current_block_type_index].d();
	      if (if_block1) if_block1.d();
	    }
	  };
	}

	// (17:4) <Section>
	function create_default_slot_2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_5 = ensure_array_like( /*loops*/ctx[3][0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_5.length; i += 1) {
	    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252) {
	        each_value_5 = ensure_array_like( /*loops*/ctx[3][0]);
	        let i;
	        for (i = 0; i < each_value_5.length; i += 1) {
	          const child_ctx = get_each_context_5(ctx, each_value_5, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_5(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_5.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (57:0) {#if $allDaySlot}
	function create_if_block$2(ctx) {
	  let div2;
	  let div1;
	  let section;
	  let t;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_1]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      div2 = element("div");
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t = space();
	      div0 = element("div");
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[5].hiddenScroll);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[5].content);
	      attr(div2, "class", div2_class_value = /*$theme*/ctx[5].allDay);
	    },
	    m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div1);
	      mount_component(section, div1, null);
	      append(div1, t);
	      append(div1, div0);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const section_changes = {};
	      if (dirty[0] & /*$_viewDates, $theme, $_viewResources, $datesAboveResources*/39 | dirty[1] & /*$$scope*/16) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div0_class_value !== (div0_class_value = /*$theme*/ctx[5].hiddenScroll)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div1_class_value !== (div1_class_value = /*$theme*/ctx[5].content)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div2_class_value !== (div2_class_value = /*$theme*/ctx[5].allDay)) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div2);
	      }
	      destroy_component(section);
	    }
	  };
	}

	// (69:16) {:else}
	function create_else_block(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_4 = ensure_array_like( /*$_viewResources*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_4.length; i += 1) {
	    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$theme, $_viewDates, $_viewResources*/35) {
	        each_value_4 = ensure_array_like( /*$_viewResources*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_4.length; i += 1) {
	          const child_ctx = get_each_context_4(ctx, each_value_4, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_4(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_4.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (61:16) {#if $datesAboveResources}
	function create_if_block_1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_2 = ensure_array_like( /*$_viewDates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$theme, $_viewResources, $_viewDates*/35) {
	        each_value_2 = ensure_array_like( /*$_viewDates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value_2.length; i += 1) {
	          const child_ctx = get_each_context_2(ctx, each_value_2, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_2(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_2.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (70:20) {#each $_viewResources as resource}
	function create_each_block_4(ctx) {
	  let div;
	  let week;
	  let t;
	  let div_class_value;
	  let current;
	  week = new Week({
	    props: {
	      dates: /*$_viewDates*/ctx[0],
	      resource: /*resource*/ctx[26]
	    }
	  });
	  return {
	    c() {
	      div = element("div");
	      create_component(week.$$.fragment);
	      t = space();
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(week, div, null);
	      append(div, t);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const week_changes = {};
	      if (dirty[0] & /*$_viewDates*/1) week_changes.dates = /*$_viewDates*/ctx[0];
	      if (dirty[0] & /*$_viewResources*/2) week_changes.resource = /*resource*/ctx[26];
	      week.$set(week_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_component(week);
	    }
	  };
	}

	// (64:28) {#each $_viewResources as resource}
	function create_each_block_3(ctx) {
	  let week;
	  let current;
	  week = new Week({
	    props: {
	      dates: [/*date*/ctx[23]],
	      resource: /*resource*/ctx[26]
	    }
	  });
	  return {
	    c() {
	      create_component(week.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const week_changes = {};
	      if (dirty[0] & /*$_viewDates*/1) week_changes.dates = [/*date*/ctx[23]];
	      if (dirty[0] & /*$_viewResources*/2) week_changes.resource = /*resource*/ctx[26];
	      week.$set(week_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	}

	// (62:20) {#each $_viewDates as date}
	function create_each_block_2(ctx) {
	  let div;
	  let t;
	  let div_class_value;
	  let current;
	  let each_value_3 = ensure_array_like( /*$_viewResources*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_3.length; i += 1) {
	    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append(div, t);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$_viewDates, $_viewResources*/3) {
	        each_value_3 = ensure_array_like( /*$_viewResources*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_3.length; i += 1) {
	          const child_ctx = get_each_context_3(ctx, each_value_3, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_3.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (60:12) <Section>
	function create_default_slot_1(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block_1, create_else_block];
	  const if_blocks = [];
	  function select_block_type_2(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type_2(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type_2(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	}

	// (84:8) {#each loops[1] as item1}
	function create_each_block_1(ctx) {
	  let day;
	  let current;
	  day = new Day$1({
	    props: {
	      date: /*$datesAboveResources*/ctx[2] ? /*item0*/ctx[17] : /*item1*/ctx[20],
	      resource: /*$datesAboveResources*/ctx[2] ? /*item1*/ctx[20] : /*item0*/ctx[17]
	    }
	  });
	  return {
	    c() {
	      create_component(day.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const day_changes = {};
	      if (dirty[0] & /*$datesAboveResources, loops*/12) day_changes.date = /*$datesAboveResources*/ctx[2] ? /*item0*/ctx[17] : /*item1*/ctx[20];
	      if (dirty[0] & /*$datesAboveResources, loops*/12) day_changes.resource = /*$datesAboveResources*/ctx[2] ? /*item1*/ctx[20] : /*item0*/ctx[17];
	      day.$set(day_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	}

	// (82:0) {#each loops[0] as item0}
	function create_each_block(ctx) {
	  let div;
	  let t;
	  let div_class_value;
	  let current;
	  let each_value_1 = ensure_array_like( /*loops*/ctx[3][1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      attr(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append(div, t);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$datesAboveResources, loops*/12) {
	        each_value_1 = ensure_array_like( /*loops*/ctx[3][1]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	// (81:0) <Body>
	function create_default_slot(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like( /*loops*/ctx[3][0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  return {
	    c() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources*/44) {
	        each_value = ensure_array_like( /*loops*/ctx[3][0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}
	function create_fragment$4(ctx) {
	  let div1;
	  let section;
	  let t0;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let t1;
	  let t2;
	  let body;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_2]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  let if_block = /*$allDaySlot*/ctx[8] && create_if_block$2(ctx);
	  body = new Body({
	    props: {
	      $$slots: {
	        default: [create_default_slot]
	      },
	      $$scope: {
	        ctx
	      }
	    }
	  });
	  return {
	    c() {
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t0 = space();
	      div0 = element("div");
	      t1 = space();
	      if (if_block) if_block.c();
	      t2 = space();
	      create_component(body.$$.fragment);
	      attr(div0, "class", div0_class_value = /*$theme*/ctx[5].hiddenScroll);
	      attr(div1, "class", div1_class_value = /*$theme*/ctx[5].header);
	    },
	    m(target, anchor) {
	      insert(target, div1, anchor);
	      mount_component(section, div1, null);
	      append(div1, t0);
	      append(div1, div0);
	      insert(target, t1, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, t2, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const section_changes = {};
	      if (dirty[0] & /*loops, $theme, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252 | dirty[1] & /*$$scope*/16) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div0_class_value !== (div0_class_value = /*$theme*/ctx[5].hiddenScroll)) {
	        attr(div0, "class", div0_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div1_class_value !== (div1_class_value = /*$theme*/ctx[5].header)) {
	        attr(div1, "class", div1_class_value);
	      }
	      if ( /*$allDaySlot*/ctx[8]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty[0] & /*$allDaySlot*/256) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t2.parentNode, t2);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      const body_changes = {};
	      if (dirty[0] & /*loops, $theme, $datesAboveResources*/44 | dirty[1] & /*$$scope*/16) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      transition_in(if_block);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(section.$$.fragment, local);
	      transition_out(if_block);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div1);
	        detach(t1);
	        detach(t2);
	      }
	      destroy_component(section);
	      if (if_block) if_block.d(detaching);
	      destroy_component(body, detaching);
	    }
	  };
	}
	function instance$1$1($$self, $$props, $$invalidate) {
	  let $_viewDates;
	  let $_viewResources;
	  let $datesAboveResources;
	  let $theme;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let $allDaySlot;
	  let {
	    datesAboveResources,
	    _viewDates,
	    _viewResources,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, datesAboveResources, value => $$invalidate(2, $datesAboveResources = value));
	  component_subscribe($$self, _viewDates, value => $$invalidate(0, $_viewDates = value));
	  component_subscribe($$self, _viewResources, value => $$invalidate(1, $_viewResources = value));
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(7, $_intlDayHeader = value));
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(6, $_intlDayHeaderAL = value));
	  component_subscribe($$self, allDaySlot, value => $$invalidate(8, $allDaySlot = value));
	  component_subscribe($$self, theme, value => $$invalidate(5, $theme = value));
	  let loops;
	  let resourceLabels = [];
	  const text_handler = (i, e) => $$invalidate(4, resourceLabels[i] = e.detail + ', ', resourceLabels);
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*$datesAboveResources, $_viewDates, $_viewResources*/7) {
	      $$invalidate(3, loops = $datesAboveResources ? [$_viewDates, $_viewResources] : [$_viewResources, $_viewDates]);
	    }
	  };
	  return [$_viewDates, $_viewResources, $datesAboveResources, loops, resourceLabels, $theme, $_intlDayHeaderAL, $_intlDayHeader, $allDaySlot, datesAboveResources, _viewDates, _viewResources, _intlDayHeader, _intlDayHeaderAL, allDaySlot, theme, text_handler];
	}
	class View extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1$1, create_fragment$4, safe_not_equal, {}, null, [-1, -1]);
	  }
	}

	/* packages/resource-time-grid/src/Auxiliary.svelte generated by Svelte v4.2.8 */

	function instance$4($$self, $$props, $$invalidate) {
	  let $resources;
	  let $_resTxtColor;
	  let $_resBgColor;
	  let {
	    resources,
	    _resBgColor,
	    _resTxtColor
	  } = getContext('state');
	  component_subscribe($$self, resources, value => $$invalidate(3, $resources = value));
	  component_subscribe($$self, _resBgColor, value => $$invalidate(5, $_resBgColor = value));
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(4, $_resTxtColor = value));
	  set_store_value(_resBgColor, $_resBgColor = event => {
	    let resource = $resources.find(res => event.resourceIds.includes(res.id));
	    return resource?.eventBackgroundColor;
	  }, $_resBgColor);
	  set_store_value(_resTxtColor, $_resTxtColor = event => {
	    let resource = $resources.find(res => event.resourceIds.includes(res.id));
	    return resource?.eventTextColor;
	  }, $_resTxtColor);
	  return [resources, _resBgColor, _resTxtColor];
	}
	let Auxiliary$1 = class Auxiliary extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$4, null, safe_not_equal, {});
	  }
	};
	var index$2 = {
	  createOptions(options) {
	    options.resources = [];
	    options.datesAboveResources = false;
	    options.filterResourcesWithEvents = false;
	    options.resourceLabelContent = undefined;
	    options.resourceLabelDidMount = undefined;
	    // Common options
	    options.buttonText.resourceTimeGridDay = 'day';
	    options.buttonText.resourceTimeGridWeek = 'week';
	    options.theme.resource = 'ec-resource';
	    options.theme.resourceTitle = 'ec-resource-title';
	    options.view = 'resourceTimeGridWeek';
	    options.views.resourceTimeGridDay = {
	      buttonText: btnTextDay,
	      component: View,
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-time-grid ec-resource-day-view')
	    };
	    options.views.resourceTimeGridWeek = {
	      buttonText: btnTextWeek,
	      component: View,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-time-grid ec-resource-week-view')
	    };
	  },
	  createParsers(parsers) {
	    parsers.resources = createResources;
	  },
	  createStores(state) {
	    if (!('_times' in state)) {
	      index$3.createStores(state);
	    }
	    state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary$1]);
	    state._viewResources = viewResources(state);
	  }
	};

	let busy = false;
	function animate(fn) {
	  if (!busy) {
	    busy = true;
	    window.requestAnimationFrame(() => {
	      fn();
	      busy = false;
	    });
	  }
	}
	function limit(value, minLimit, maxLimit) {
	  return max(minLimit, min(maxLimit, value));
	}

	/* packages/interaction/src/Action.svelte generated by Svelte v4.2.8 */

	const {
	  window: window_1
	} = globals;
	function create_fragment$3(ctx) {
	  let mounted;
	  let dispose;
	  return {
	    c: noop,
	    m(target, anchor) {
	      if (!mounted) {
	        dispose = [listen(window_1, "pointermove", /*handlePointerMove*/ctx[32]), listen(window_1, "pointerup", /*handlePointerUp*/ctx[33]), listen(window_1, "pointercancel", /*handlePointerUp*/ctx[33]), listen(window_1, "scroll", /*handleScroll*/ctx[0]), listen(window_1, "selectstart", createPreventDefaultHandler( /*complexAction*/ctx[34])), listen(window_1, "contextmenu", function () {
	          if (is_function(createPreventDefaultHandler( /*contextmenu_handler*/ctx[42]))) createPreventDefaultHandler( /*contextmenu_handler*/ctx[42]).apply(this, arguments);
	        }), listen(window_1, "touchstart", /*handleTouchStart*/ctx[35]), listen(window_1, "touchmove", /*touchmove_handler*/ctx[41], {
	          passive: false
	        })];
	        mounted = true;
	      }
	    },
	    p(new_ctx, dirty) {
	      ctx = new_ctx;
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	const ACTION_DRAG = 1;
	const ACTION_RESIZE = 2;
	const ACTION_SELECT = 3;
	const ACTION_CLICK = 4;
	const ACTION_NO_ACTION = 5;
	function validJsEvent(jsEvent) {
	  return jsEvent.isPrimary && (jsEvent.pointerType !== 'mouse' || jsEvent.buttons & 1);
	}
	function createPreventDefaultHandler(condition) {
	  return jsEvent => {
	    if (condition()) {
	      jsEvent.preventDefault();
	    }
	  };
	}
	function instance$3($$self, $$props, $$invalidate) {
	  let $_view;
	  let $unselectFn;
	  let $_events;
	  let $_iEvents;
	  let $selectBackgroundColor;
	  let $_customGrid;
	  let $_dayGrid;
	  let $_iClass;
	  let $dateClick;
	  let $eventDrop;
	  let $eventResize;
	  let $eventDragStop;
	  let $eventResizeStop;
	  let $selectFn;
	  let $unselectCancel;
	  let $unselectAuto;
	  let $slotHeight;
	  let $dragScroll;
	  let $eventDragStart;
	  let $eventResizeStart;
	  let $eventDragMinDistance;
	  let $selectMinDistance;
	  let $longPressDelay;
	  let $eventLongPressDelay;
	  let $selectLongPressDelay;
	  let $datesAboveResources;
	  let $slotDuration;
	  let $view;
	  let $selectable;
	  let $_draggable;
	  let {
	    _iEvents,
	    _iClass,
	    _events,
	    _view,
	    _dayGrid,
	    _customGrid,
	    _draggable,
	    dateClick,
	    dragScroll,
	    datesAboveResources,
	    eventDragMinDistance,
	    eventDragStart,
	    eventDragStop,
	    eventDrop,
	    eventLongPressDelay,
	    eventResizeStart,
	    eventResizeStop,
	    eventResize,
	    longPressDelay,
	    selectable,
	    select: selectFn,
	    selectBackgroundColor,
	    selectLongPressDelay,
	    selectMinDistance,
	    slotDuration,
	    slotHeight,
	    unselect: unselectFn,
	    unselectAuto,
	    unselectCancel,
	    view
	  } = getContext('state');
	  component_subscribe($$self, _iEvents, value => $$invalidate(70, $_iEvents = value));
	  component_subscribe($$self, _iClass, value => $$invalidate(74, $_iClass = value));
	  component_subscribe($$self, _events, value => $$invalidate(69, $_events = value));
	  component_subscribe($$self, _view, value => $$invalidate(67, $_view = value));
	  component_subscribe($$self, _dayGrid, value => $$invalidate(73, $_dayGrid = value));
	  component_subscribe($$self, _customGrid, value => $$invalidate(72, $_customGrid = value));
	  component_subscribe($$self, _draggable, value => $$invalidate(96, $_draggable = value));
	  component_subscribe($$self, dateClick, value => $$invalidate(75, $dateClick = value));
	  component_subscribe($$self, dragScroll, value => $$invalidate(84, $dragScroll = value));
	  component_subscribe($$self, datesAboveResources, value => $$invalidate(92, $datesAboveResources = value));
	  component_subscribe($$self, eventDragMinDistance, value => $$invalidate(87, $eventDragMinDistance = value));
	  component_subscribe($$self, eventDragStart, value => $$invalidate(85, $eventDragStart = value));
	  component_subscribe($$self, eventDragStop, value => $$invalidate(78, $eventDragStop = value));
	  component_subscribe($$self, eventDrop, value => $$invalidate(76, $eventDrop = value));
	  component_subscribe($$self, eventLongPressDelay, value => $$invalidate(90, $eventLongPressDelay = value));
	  component_subscribe($$self, eventResizeStart, value => $$invalidate(86, $eventResizeStart = value));
	  component_subscribe($$self, eventResizeStop, value => $$invalidate(79, $eventResizeStop = value));
	  component_subscribe($$self, eventResize, value => $$invalidate(77, $eventResize = value));
	  component_subscribe($$self, longPressDelay, value => $$invalidate(89, $longPressDelay = value));
	  component_subscribe($$self, selectable, value => $$invalidate(95, $selectable = value));
	  component_subscribe($$self, selectFn, value => $$invalidate(80, $selectFn = value));
	  component_subscribe($$self, selectBackgroundColor, value => $$invalidate(71, $selectBackgroundColor = value));
	  component_subscribe($$self, selectLongPressDelay, value => $$invalidate(91, $selectLongPressDelay = value));
	  component_subscribe($$self, selectMinDistance, value => $$invalidate(88, $selectMinDistance = value));
	  component_subscribe($$self, slotDuration, value => $$invalidate(93, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(83, $slotHeight = value));
	  component_subscribe($$self, unselectFn, value => $$invalidate(68, $unselectFn = value));
	  component_subscribe($$self, unselectAuto, value => $$invalidate(82, $unselectAuto = value));
	  component_subscribe($$self, unselectCancel, value => $$invalidate(81, $unselectCancel = value));
	  component_subscribe($$self, view, value => $$invalidate(94, $view = value));
	  let action;
	  let interacting;
	  let event;
	  let display;
	  let date, newDate;
	  let resource, newResource;
	  let fromX, fromY;
	  let toX, toY;
	  let bodyEl, bodyRect, clipEl, clipRect;
	  let delta;
	  let allDay;
	  let iClass;
	  let minEnd; // minimum end time when resizing
	  let selectStep; // minimum selection step
	  let selected; // whether selection has been made
	  let noDateClick; // do not perform date click
	  let timer; // timer for long press delays
	  let viewport;
	  function drag(eventToDrag, jsEvent, resize, forceDate) {
	    if (!action) {
	      action = validJsEvent(jsEvent) ? resize ? ACTION_RESIZE : $_draggable(eventToDrag) ? ACTION_DRAG : ACTION_NO_ACTION : ACTION_NO_ACTION;
	      if (complexAction()) {
	        event = eventToDrag;
	        common(jsEvent);
	        if (forceDate) {
	          // Force date in popup
	          date = forceDate;
	        }
	        iClass = resize ? allDay ? 'resizingX' : 'resizingY' : 'dragging';
	        if (resize) {
	          minEnd = cloneDate(event.start);
	          if (allDay) {
	            minEnd.setUTCHours(event.end.getUTCHours(), event.end.getUTCMinutes(), event.end.getUTCSeconds(), 0);
	            if (minEnd < event.start) {
	              addDay(minEnd);
	            } // minEnd = addDuration(cloneDate(event.start), $slotDuration);  alternative version
	          } else {
	            addDuration(minEnd, $slotDuration);
	          }
	        }
	        move(jsEvent);
	      }
	    }
	  }
	  function select(jsEvent) {
	    if (!action) {
	      action = validJsEvent(jsEvent) ? $selectable && !listView($view) ? ACTION_SELECT : ACTION_CLICK : ACTION_NO_ACTION;
	      if (complexAction()) {
	        common(jsEvent);
	        iClass = 'selecting';
	        selectStep = allDay ? createDuration({
	          day: 1
	        }) : $slotDuration;

	        // Create dummy source event
	        event = {
	          allDay,
	          start: date,
	          end: addDuration(cloneDate(date), selectStep),
	          resourceIds: resource ? [resource.id] : []
	        };
	        move(jsEvent);
	      }
	    }
	  }
	  function noAction() {
	    if (!action) {
	      action = ACTION_NO_ACTION;
	    }
	  }
	  function common(jsEvent) {
	    window.getSelection().removeAllRanges();
	    fromX = toX = jsEvent.clientX;
	    fromY = toY = jsEvent.clientY;
	    let dayEl = getElementWithPayload(toX, toY);
	    ({
	      allDay,
	      date,
	      resource
	    } = getPayload(dayEl)(toY));
	    bodyEl = ancestor(dayEl, resource ? 4 : 3);
	    clipEl = ancestor(dayEl, resource && (dragging() || $datesAboveResources) ? 2 : 1);
	    calcViewport();
	    if (jsEvent.pointerType !== 'mouse') {
	      // For touch devices init long press delay
	      $$invalidate(1, timer = setTimeout(() => {
	        if (action) {
	          interacting = true;
	          move(jsEvent);
	        }
	      }, (selecting() ? $selectLongPressDelay : $eventLongPressDelay) ?? $longPressDelay));
	    }
	  }
	  function move(jsEvent) {
	    if (interacting || jsEvent && jsEvent.pointerType === 'mouse' && distance() >= (selecting() ? $selectMinDistance : $eventDragMinDistance)) {
	      interacting = true;
	      unselect(jsEvent);
	      set_store_value(_iClass, $_iClass = iClass, $_iClass);
	      if (!$_iEvents[0]) {
	        if (selecting()) {
	          createIEventSelect();
	        } else {
	          createIEvent(jsEvent, resizing() ? $eventResizeStart : $eventDragStart);
	        }
	      }
	      let dayEl = findDayEl();
	      if (dayEl) {
	        let newAllDay;
	        ({
	          allDay: newAllDay,
	          date: newDate,
	          resource: newResource
	        } = getPayload(dayEl)(toY));
	        if (newAllDay === allDay) {
	          delta = createDuration((newDate - date) / 1000);
	          set_store_value(_iEvents, $_iEvents[0].end = addDuration(cloneDate(event.end), delta), $_iEvents);
	          if (resizing()) {
	            // Resizing
	            if ($_iEvents[0].end < minEnd) {
	              set_store_value(_iEvents, $_iEvents[0].end = minEnd, $_iEvents);
	            }
	          } else if (selecting()) {
	            // Selecting
	            if ($_iEvents[0].end < event.end) {
	              set_store_value(_iEvents, $_iEvents[0].start = subtractDuration($_iEvents[0].end, selectStep), $_iEvents);
	              set_store_value(_iEvents, $_iEvents[0].end = event.end, $_iEvents);
	            } else {
	              set_store_value(_iEvents, $_iEvents[0].start = event.start, $_iEvents);
	            }
	          } else {
	            // Dragging
	            set_store_value(_iEvents, $_iEvents[0].start = addDuration(cloneDate(event.start), delta), $_iEvents);
	            if (resource) {
	              set_store_value(_iEvents, $_iEvents[0].resourceIds = event.resourceIds.filter(id => id !== resource.id), $_iEvents);
	              $_iEvents[0].resourceIds.push(newResource.id);
	            }
	          }
	        }
	      }
	    }
	    if ($dragScroll) {
	      let threshold = $slotHeight * 2;
	      animate(() => {
	        if (bodyEl) {
	          if (toY < threshold) {
	            window.scrollBy(0, max(-10, (toY - threshold) / 3));
	          }
	          if (toY < bodyRect.top + threshold) {
	            bodyEl.scrollTop += max(-10, (toY - bodyRect.top - threshold) / 3);
	          }
	          if (toY > window.innerHeight - threshold) {
	            window.scrollBy(0, min(10, (toY - window.innerHeight + threshold) / 3));
	          }
	          if (toY > bodyRect.bottom - threshold) {
	            bodyEl.scrollTop += min(10, (toY - bodyRect.bottom + threshold) / 3);
	          }
	        }
	      });
	    }
	  }
	  function handleScroll() {
	    if (complexAction()) {
	      calcViewport();
	      move();
	    }
	  }
	  function handlePointerMove(jsEvent) {
	    if (complexAction() && jsEvent.isPrimary) {
	      toX = jsEvent.clientX;
	      toY = jsEvent.clientY;
	      move(jsEvent);
	    }
	  }
	  function handlePointerUp(jsEvent) {
	    if (selected && $unselectAuto && !($unselectCancel && jsEvent.target.closest($unselectCancel))) {
	      unselect(jsEvent);
	    }
	    if (action && jsEvent.isPrimary) {
	      if (interacting) {
	        if (selecting()) {
	          selected = true;
	          if (is_function($selectFn)) {
	            let {
	              start,
	              end
	            } = toEventWithLocalDates($_iEvents[0]);
	            $selectFn({
	              start,
	              end,
	              startStr: toISOString($_iEvents[0].start),
	              endStr: toISOString($_iEvents[0].end),
	              allDay,
	              jsEvent,
	              view: toViewWithLocalDates($_view),
	              resource
	            });
	          }
	        } else {
	          event.display = display;
	          let callback = resizing() ? $eventResizeStop : $eventDragStop;
	          if (is_function(callback)) {
	            callback({
	              event: toEventWithLocalDates(event),
	              jsEvent,
	              view: toViewWithLocalDates($_view)
	            });
	          }
	          let oldEvent = cloneEvent(event);
	          updateEvent(event, $_iEvents[0]);
	          destroyIEvent();
	          callback = resizing() ? $eventResize : $eventDrop;
	          if (is_function(callback)) {
	            let eventRef = event;
	            let info;
	            if (resizing()) {
	              info = {
	                endDelta: delta
	              };
	            } else {
	              info = {
	                delta,
	                oldResource: resource !== newResource ? resource : undefined,
	                newResource: resource !== newResource ? newResource : undefined
	              };
	            }
	            callback(assign(info, {
	              event: toEventWithLocalDates(event),
	              oldEvent: toEventWithLocalDates(oldEvent),
	              jsEvent,
	              view: toViewWithLocalDates($_view),
	              revert() {
	                updateEvent(eventRef, oldEvent);
	              }
	            }));
	          }
	        }
	      } else {
	        if (clicking() || selecting()) {
	          // Perform date click
	          if (is_function($dateClick) && !noDateClick) {
	            toX = jsEvent.clientX;
	            toY = jsEvent.clientY;
	            let dayEl = getElementWithPayload(toX, toY);
	            if (dayEl) {
	              let {
	                allDay,
	                date,
	                resource
	              } = getPayload(dayEl)(toY);
	              $dateClick({
	                allDay,
	                date: toLocalDate(date),
	                dateStr: toISOString(date),
	                dayEl,
	                jsEvent,
	                view: toViewWithLocalDates($_view),
	                resource
	              });
	            }
	          }
	        }
	      }
	      interacting = false;
	      action = fromX = fromY = toX = toY = event = display = date = newDate = resource = newResource = delta = allDay = set_store_value(_iClass, $_iClass = minEnd = selectStep = undefined, $_iClass);
	      bodyEl = clipEl = bodyRect = clipRect = undefined;
	      if (timer) {
	        clearTimeout(timer);
	        $$invalidate(1, timer = undefined);
	      }
	    }
	    noDateClick = false;
	  }
	  function findDayEl() {
	    // Limit coordinates to viewport
	    return getElementWithPayload(limit(toX, viewport[0], viewport[1]), limit(toY, viewport[2], viewport[3]));
	  }
	  function calcViewport() {
	    bodyRect = rect(bodyEl);
	    clipRect = rect(clipEl);
	    viewport = [
	    //            max(0, clipRect.left + ($_dayGrid ? 0 : 8)),  // left
	    max(0, clipRect.left + ($_dayGrid || $_customGrid ? 0 : 8)), min(document.documentElement.clientWidth, clipRect.right) - 2, max(0, bodyRect.top // top
	    ), min(document.documentElement.clientHeight, bodyRect.bottom) - 2]; // bottom
	  }
	  function createIEvent(jsEvent, callback) {
	    if (is_function(callback)) {
	      callback({
	        event: toEventWithLocalDates(event),
	        jsEvent,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	    display = event.display;
	    event.display = 'preview';
	    set_store_value(_iEvents, $_iEvents[0] = cloneEvent(event), $_iEvents);
	    event.display = 'ghost';
	    _events.set($_events);
	  }
	  function createIEventSelect() {
	    set_store_value(_iEvents, $_iEvents[0] = {
	      id: '{select}',
	      allDay: event.allDay,
	      start: event.start,
	      title: '',
	      display: 'preview',
	      extendedProps: {},
	      backgroundColor: $selectBackgroundColor,
	      resourceIds: event.resourceIds
	    }, $_iEvents);
	  }
	  function destroyIEvent() {
	    set_store_value(_iEvents, $_iEvents[0] = null, $_iEvents);
	  }
	  function updateEvent(target, source) {
	    target.start = source.start;
	    target.end = source.end;
	    target.resourceIds = source.resourceIds;
	    _events.set($_events);
	  }
	  function distance() {
	    return Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
	  }
	  function dragging() {
	    return action === ACTION_DRAG;
	  }
	  function resizing() {
	    return action === ACTION_RESIZE;
	  }
	  function clicking() {
	    return action === ACTION_CLICK;
	  }
	  function selecting() {
	    return action === ACTION_SELECT;
	  }
	  function complexAction() {
	    return action && action < ACTION_CLICK;
	  }
	  function unselect(jsEvent) {
	    if (selected) {
	      selected = false;
	      destroyIEvent();
	      if (is_function($unselectFn)) {
	        $unselectFn({
	          jsEvent,
	          view: toViewWithLocalDates($_view)
	        });
	      }
	    }
	  }
	  function noClick() {
	    noDateClick = true;
	  }

	  // Clear selection on view params change
	  _view.subscribe(unselect);
	  function handleTouchStart(jsEvent) {
	    if (complexAction()) {
	      let target = jsEvent.target;
	      let stops = [];
	      let stop = () => run_all(stops);
	      stops.push(listen(target, 'touchmove', createPreventDefaultHandler(() => interacting)));
	      stops.push(listen(target, 'touchend', stop));
	      stops.push(listen(target, 'touchcancel', stop));
	    }
	  }
	  function touchmove_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  const contextmenu_handler = () => timer;
	  return [handleScroll, timer, _iEvents, _iClass, _events, _view, _dayGrid, _customGrid, _draggable, dateClick, dragScroll, datesAboveResources, eventDragMinDistance, eventDragStart, eventDragStop, eventDrop, eventLongPressDelay, eventResizeStart, eventResizeStop, eventResize, longPressDelay, selectable, selectFn, selectBackgroundColor, selectLongPressDelay, selectMinDistance, slotDuration, slotHeight, unselectFn, unselectAuto, unselectCancel, view, handlePointerMove, handlePointerUp, complexAction, handleTouchStart, drag, select, noAction, unselect, noClick, touchmove_handler, contextmenu_handler];
	}
	class Action extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$3, create_fragment$3, safe_not_equal, {
	      drag: 36,
	      select: 37,
	      noAction: 38,
	      handleScroll: 0,
	      unselect: 39,
	      noClick: 40
	    }, null, [-1, -1, -1, -1]);
	  }
	  get drag() {
	    return this.$$.ctx[36];
	  }
	  get select() {
	    return this.$$.ctx[37];
	  }
	  get noAction() {
	    return this.$$.ctx[38];
	  }
	  get handleScroll() {
	    return this.$$.ctx[0];
	  }
	  get unselect() {
	    return this.$$.ctx[39];
	  }
	  get noClick() {
	    return this.$$.ctx[40];
	  }
	}

	/* packages/interaction/src/Pointer.svelte generated by Svelte v4.2.8 */

	function create_fragment$2(ctx) {
	  let mounted;
	  let dispose;
	  return {
	    c: noop,
	    m(target, anchor) {
	      if (!mounted) {
	        dispose = [listen(window, "pointermove", /*handlePointerMove*/ctx[5]), listen(window, "scroll", /*handleScroll*/ctx[0])];
	        mounted = true;
	      }
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d(detaching) {
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}
	function validEvent(jsEvent) {
	  return jsEvent.isPrimary && jsEvent.pointerType === 'mouse';
	}
	function instance$2($$self, $$props, $$invalidate) {
	  let $_iEvents;
	  let $slotDuration;
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let {
	    _iEvents,
	    _events,
	    _viewDates,
	    _slotTimeLimits,
	    slotDuration,
	    slotHeight,
	    hiddenDays,
	    _view,
	    datesAboveResources,
	    theme
	  } = getContext('state');
	  component_subscribe($$self, _iEvents, value => $$invalidate(10, $_iEvents = value));
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(19, $_slotTimeLimits = value));
	  component_subscribe($$self, slotDuration, value => $$invalidate(17, $slotDuration = value));
	  component_subscribe($$self, slotHeight, value => $$invalidate(18, $slotHeight = value));
	  let y;
	  let colDate;
	  let colEl;
	  let colRect;
	  let resource;
	  let date;
	  function enterTimeGrid(date, el, jsEvent, resourceObj) {
	    if (validEvent(jsEvent)) {
	      colDate = date;
	      colEl = el;
	      colRect = rect(colEl);
	      y = jsEvent.clientY;
	      resource = resourceObj;
	    }
	  }
	  function enterDayGrid(date, jsEvent) {
	    if (validEvent(jsEvent)) {
	      colDate = date;
	      colEl = null;
	      y = resource = undefined;
	    }
	  }
	  function enterCustomGrid(date, jsEvent) {
	    if (validEvent(jsEvent)) {
	      colDate = date;
	      colEl = null;
	      y = resource = undefined;
	    }
	  }
	  function leave(jsEvent) {
	    if (validEvent(jsEvent)) {
	      removePointerEvent();
	    }
	  }
	  function move() {
	    if (!colDate) {
	      return;
	    }
	    if (colEl) {
	      // timeGrid
	      let ry = y - colRect.top;
	      date = addDuration(addDuration(cloneDate(colDate), $_slotTimeLimits.min), $slotDuration, floor(ry / $slotHeight));
	    } else {
	      // dayGrid & customGrid
	      date = colDate;
	    }
	    if (!$_iEvents[1]) {
	      createPointerEvent();
	    }
	    set_store_value(_iEvents, $_iEvents[1].start = date, $_iEvents);
	    set_store_value(_iEvents, $_iEvents[1].end = addDuration(cloneDate(date), $slotDuration), $_iEvents);
	    set_store_value(_iEvents, $_iEvents[1].resourceIds = resource ? [resource.id] : [], $_iEvents);
	  }
	  function handleScroll() {
	    if (colEl) {
	      colRect = rect(colEl);
	      move();
	    }
	  }
	  function handlePointerMove(jsEvent) {
	    if (validEvent(jsEvent)) {
	      y = jsEvent.clientY;
	      move();
	    }
	  }
	  function createPointerEvent() {
	    set_store_value(_iEvents, $_iEvents[1] = {
	      id: '{pointer}',
	      title: '',
	      display: 'pointer',
	      extendedProps: {},
	      backgroundColor: 'transparent'
	    }, $_iEvents);
	  }
	  function removePointerEvent() {
	    colDate = colEl = set_store_value(_iEvents, $_iEvents[1] = null, $_iEvents);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_iEvents*/1024) {
	      if ($_iEvents[0]) {
	        removePointerEvent();
	      }
	    }
	  };
	  return [handleScroll, _iEvents, _slotTimeLimits, slotDuration, slotHeight, handlePointerMove, enterTimeGrid, enterDayGrid, enterCustomGrid, leave, $_iEvents];
	}
	class Pointer extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
	      enterTimeGrid: 6,
	      enterDayGrid: 7,
	      enterCustomGrid: 8,
	      leave: 9,
	      handleScroll: 0
	    });
	  }
	  get enterTimeGrid() {
	    return this.$$.ctx[6];
	  }
	  get enterDayGrid() {
	    return this.$$.ctx[7];
	  }
	  get enterCustomGrid() {
	    return this.$$.ctx[8];
	  }
	  get leave() {
	    return this.$$.ctx[9];
	  }
	  get handleScroll() {
	    return this.$$.ctx[0];
	  }
	}

	/* packages/interaction/src/Resizer.svelte generated by Svelte v4.2.8 */

	function create_if_block$1(ctx) {
	  let div;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  return {
	    c() {
	      div = element("div");
	      attr(div, "class", div_class_value = /*$theme*/ctx[1].resizer);
	    },
	    m(target, anchor) {
	      insert(target, div, anchor);
	      if (!mounted) {
	        dispose = listen(div, "pointerdown", /*pointerdown_handler*/ctx[8]);
	        mounted = true;
	      }
	    },
	    p(ctx, dirty) {
	      if (dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].resizer)) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	}
	function create_fragment$1(ctx) {
	  let if_block_anchor;
	  let if_block = /*resizable*/ctx[0] && create_if_block$1(ctx);
	  return {
	    c() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	    },
	    p(ctx, _ref) {
	      let [dirty] = _ref;
	      if ( /*resizable*/ctx[0]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$1(ctx);
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d(detaching) {
	      if (detaching) {
	        detach(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	}
	function instance$1($$self, $$props, $$invalidate) {
	  let $editable;
	  let $eventDurationEditable;
	  let $theme;
	  let {
	    event
	  } = $$props;
	  let {
	    theme,
	    eventDurationEditable,
	    editable
	  } = getContext('state');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  component_subscribe($$self, eventDurationEditable, value => $$invalidate(7, $eventDurationEditable = value));
	  component_subscribe($$self, editable, value => $$invalidate(6, $editable = value));
	  let resizable;
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  $$self.$$set = $$props => {
	    if ('event' in $$props) $$invalidate(5, event = $$props.event);
	  };
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*event, $eventDurationEditable, $editable*/224) {
	      $$invalidate(0, resizable = !bgEvent(event.display) && !helperEvent(event.display) && ((event.durationEditable ?? $eventDurationEditable) || (event.editable ?? $editable)));
	    }
	  };
	  return [resizable, $theme, theme, eventDurationEditable, editable, event, $editable, $eventDurationEditable, pointerdown_handler];
	}
	class Resizer extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
	      event: 5
	    });
	  }
	}

	/* packages/interaction/src/Auxiliary.svelte generated by Svelte v4.2.8 */

	function create_if_block(ctx) {
	  let pointer_1;
	  let current;
	  let pointer_1_props = {};
	  pointer_1 = new Pointer({
	    props: pointer_1_props
	  });
	  /*pointer_1_binding*/
	  ctx[16](pointer_1);
	  return {
	    c() {
	      create_component(pointer_1.$$.fragment);
	    },
	    m(target, anchor) {
	      mount_component(pointer_1, target, anchor);
	      current = true;
	    },
	    p(ctx, dirty) {
	      const pointer_1_changes = {};
	      pointer_1.$set(pointer_1_changes);
	    },
	    i(local) {
	      if (current) return;
	      transition_in(pointer_1.$$.fragment, local);
	      current = true;
	    },
	    o(local) {
	      transition_out(pointer_1.$$.fragment, local);
	      current = false;
	    },
	    d(detaching) {
	      /*pointer_1_binding*/ctx[16](null);
	      destroy_component(pointer_1, detaching);
	    }
	  };
	}
	function create_fragment(ctx) {
	  let action;
	  let t;
	  let if_block_anchor;
	  let current;
	  let action_props = {};
	  action = new Action({
	    props: action_props
	  });
	  /*action_binding*/
	  ctx[15](action);
	  let if_block = /*$pointer*/ctx[1] && create_if_block(ctx);
	  return {
	    c() {
	      create_component(action.$$.fragment);
	      t = space();
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m(target, anchor) {
	      mount_component(action, target, anchor);
	      insert(target, t, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p(ctx, _ref2) {
	      let [dirty] = _ref2;
	      const action_changes = {};
	      action.$set(action_changes);
	      if ( /*$pointer*/ctx[1]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*$pointer*/2) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i(local) {
	      if (current) return;
	      transition_in(action.$$.fragment, local);
	      transition_in(if_block);
	      current = true;
	    },
	    o(local) {
	      transition_out(action.$$.fragment, local);
	      transition_out(if_block);
	      current = false;
	    },
	    d(detaching) {
	      if (detaching) {
	        detach(t);
	        detach(if_block_anchor);
	      }

	      /*action_binding*/
	      ctx[15](null);
	      destroy_component(action, detaching);
	      if (if_block) if_block.d(detaching);
	    }
	  };
	}
	function instance($$self, $$props, $$invalidate) {
	  let $_interaction;
	  let $_bodyEl;
	  let $theme;
	  let $_draggable;
	  let $_iClasses;
	  let $editable;
	  let $eventStartEditable;
	  let $pointer;
	  let {
	    theme,
	    editable,
	    eventStartEditable,
	    eventDurationEditable,
	    pointer,
	    _bodyEl,
	    _interaction,
	    _iClasses,
	    _draggable
	  } = getContext('state');
	  component_subscribe($$self, theme, value => $$invalidate(11, $theme = value));
	  component_subscribe($$self, editable, value => $$invalidate(13, $editable = value));
	  component_subscribe($$self, eventStartEditable, value => $$invalidate(14, $eventStartEditable = value));
	  component_subscribe($$self, pointer, value => $$invalidate(1, $pointer = value));
	  component_subscribe($$self, _bodyEl, value => $$invalidate(10, $_bodyEl = value));
	  component_subscribe($$self, _interaction, value => $$invalidate(0, $_interaction = value));
	  component_subscribe($$self, _iClasses, value => $$invalidate(17, $_iClasses = value));
	  component_subscribe($$self, _draggable, value => $$invalidate(12, $_draggable = value));
	  set_store_value(_interaction, $_interaction.resizer = Resizer, $_interaction);
	  function bodyScrollHandler() {
	    for (let component of Object.values($_interaction)) {
	      component?.handleScroll?.();
	    }
	  }
	  function action_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_interaction.action = $$value;
	      _interaction.set($_interaction);
	    });
	  }
	  function pointer_1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_interaction.pointer = $$value;
	      _interaction.set($_interaction);
	    });
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$eventStartEditable, $editable*/24576) {
	      set_store_value(_draggable, $_draggable = event => (event.startEditable ?? $eventStartEditable) || (event.editable ?? $editable), $_draggable);
	    }
	    if ($$self.$$.dirty & /*$theme, $_draggable*/6144) {
	      set_store_value(_iClasses, $_iClasses = (className, event) => {
	        let {
	          display
	        } = event;
	        return helperEvent(display) ? [$theme[display]] : !bgEvent(display) && $_draggable(event) ? [$theme.draggable] : [];
	      }, $_iClasses);
	    }
	    if ($$self.$$.dirty & /*$_bodyEl*/1024) {
	      if ($_bodyEl) {
	        listen($_bodyEl, 'scroll', bodyScrollHandler);
	      }
	    }
	  };
	  return [$_interaction, $pointer, theme, editable, eventStartEditable, pointer, _bodyEl, _interaction, _iClasses, _draggable, $_bodyEl, $theme, $_draggable, $editable, $eventStartEditable, action_binding, pointer_1_binding];
	}
	class Auxiliary extends SvelteComponent {
	  constructor(options) {
	    super();
	    init(this, options, instance, create_fragment, safe_not_equal, {});
	  }
	}
	var index$1 = {
	  createOptions(options) {
	    options.dateClick = undefined;
	    options.dragScroll = true;
	    options.editable = false;
	    options.eventDragMinDistance = 5;
	    options.eventDragStart = undefined;
	    options.eventDragStop = undefined;
	    options.eventDrop = undefined;
	    options.eventDurationEditable = true;
	    options.eventLongPressDelay = undefined;
	    options.eventResizeStart = undefined;
	    options.eventResizeStop = undefined;
	    options.eventResize = undefined;
	    options.eventStartEditable = true;
	    options.longPressDelay = 1000;
	    options.pointer = false;
	    options.select = undefined;
	    options.selectBackgroundColor = undefined; // ec option
	    options.selectLongPressDelay = undefined;
	    options.selectMinDistance = 5;
	    options.unselect = undefined;
	    options.unselectAuto = true;
	    options.unselectCancel = '';
	    options.theme.draggable = 'ec-draggable';
	    options.theme.ghost = 'ec-ghost';
	    options.theme.preview = 'ec-preview';
	    options.theme.pointer = 'ec-pointer';
	    options.theme.resizer = 'ec-resizer';
	    options.theme.dragging = 'ec-dragging';
	    options.theme.resizingY = 'ec-resizing-y';
	    options.theme.resizingX = 'ec-resizing-x';
	    options.theme.selecting = 'ec-selecting';
	  },
	  createStores(state) {
	    state._draggable = writable(noop);
	    state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary]);
	  }
	};

	class index extends Calendar {
	  constructor(el, options) {
	    super({
	      target: el,
	      props: {
	        plugins: [index$5, index$6, index$4, index$3, index$2, index$1],
	        options
	      }
	    });
	  }
	  get view() {
	    return this.getView();
	  }
	}

	return index;

})();
//# sourceMappingURL=event-calendar.min.js.map
